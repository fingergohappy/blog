{"posts":[{"title":"gradle将spring-boot和vue打入一个jar包","text":"之前用maven搞过将spring-boot和vue打成一个jar包,现在的项目,我使用了gralde,又是同样的需求,使用gradle的composite似乎更优雅一些. 项目结构123456789.├── build.gradle.kts├── settings.gradle.kts├── app #spring-boot 目录│ ├── build.gradle.kts│ ├── settings.gradle.kts├── web #vue目录│ ├── build.gradle.kts│ ├── settings.gradle.kts 结构说明app和web分别为spring-boot和vue项目,就正常写就行,唯一不同的就是,vue项目里面添加一个gradle配置文件 配置文件说明需要改动的地方就只有web和最外面的项目的gradle的配置文件需要改动 web其中web的build.gradle.kts内容如下: 12345678910plugins{ base}tasks{ register&lt;Exec&gt;(&quot;build-dev&quot;){ workingDir(&quot;./&quot;) commandLine(&quot;pnpm&quot;,&quot;run&quot;,&quot;build:dev&quot;) }} 就是添加了一个打包任务 根目录根目录的gradle配置文件需要调整的地方比较多 setting.gradle.kts: 12345rootProject.name = &quot;example&quot;// 这里很重要,使用includeBuild完成组合构建includeBuild(&quot;./app&quot;)includeBuild(&quot;./web&quot;) build.gradle.kts: 123456789101112131415161718192021222324plugins { base}tasks{ register(&quot;build-all&quot;){ dependsOn(gradle.includedBuild(&quot;app&quot;).task(&quot;:classes&quot;)) dependsOn(gradle.includedBuild(&quot;web&quot;).task(&quot;:build-dev&quot;)) } register&lt;Copy&gt;(&quot;copy-static&quot;){ dependsOn(&quot;build-all&quot;) // gradle没有提供通过includeBuild直接获取build目录的api,只能这样写死 val webDistPath = gradle.includedBuild(&quot;web&quot;).projectDir.getPath() + &quot;/dist-dev&quot; val appClassesPath = gradle.includedBuild(&quot;app&quot;).projectDir.getPath() + &quot;/build/resources/main/static&quot; from(webDistPath){ include(&quot;*&quot;) } into(appClassesPath) } register(&quot;build-jar&quot;){ dependsOn(&quot;copy-static&quot;) dependsOn(gradle.includedBuild(&quot;app&quot;).task(&quot;:jar&quot;)) }} 这样执行gradle :build-jar,就会生成一个带有vue打包后的dist目录的jar包","link":"/2023/11/11/gradle-spring-boot-vue-one-jar/"},{"title":"hexo push后自动部署github pages","text":"hexo有几种部署方式,一种是本地编译后,直接push public路径下的静态文件,一种是通过cli方式,向仓库提交source下的的markdown文件,触发action.实现自动部署 本文主要说明后一种方式. 创建github workflow在hexo的根目录的.github/workflows/pages.yml路径下创建文件,文件内容: 12345678910111213141516171819202122232425262728293031323334353637383940name: Pageson: push: branches: - main # default branchjobs: pages: runs-on: ubuntu-latest permissions: contents: write steps: - uses: actions/checkout@v3 with: token: ${{ secrets.GITHUB_TOKEN }} # If your repository depends on submodule, please see: https://github.com/actions/checkout submodules: recursive - name: Use Node.js 16.x uses: actions/setup-node@v2 with: # 看下自己本地的noe版本 node-version: '16' - name: Cache NPM dependencies uses: actions/cache@v2 with: path: node_modules key: ${{ runner.OS }}-npm-cache restore-keys: | ${{ runner.OS }}-npm-cache - name: Install Dependencies run: npm install - name: Build run: npm run build - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 创建github pages参考 https://docs.github.com/en/pages/getting-started-with-github-pages/creating-a-github-pages-site 创建完成后,微调一下: 在settings-&gt;Pages-&gt;Build and deployment-&gt;Branch选项中,把branch改成gh-pages 初始化本地仓库1234git init .git remote add origin ${你上面创建的仓库地址}git remote add .git commit -m &quot;init project&quot; gitgnore由于使用了github的自动部署功能,所以无需上传静态文件,在hexo根目录添加.gitignore文件 123public/.deploy*/node_modules 提交最后提交到main分支 1git push -u origin main 提交完成后,在github的action选项中可以看到正在构建,构建完成,就可以在https://${your-username}.github.io路径访问你的在线博客了 参考https://hexo.io/docs/github-pages","link":"/2023/09/20/hexo-auto-deploy/"},{"title":"gradle spring boot 打包无依赖jar","text":"背景希望spring-boot的jar包不包含项目的依赖,打包成一个轻量jar包,方便部署和快速打包 方法一:修改build.gradle.kts: 123456789101112tasks.withType&lt;Jar&gt;{ manifest { attributes[&quot;Main-Class&quot;] = &quot;com.io.alyze.AlyzeApplicationKt&quot; //添加所有依赖的 attributes[&quot;Class-Path&quot;] = configurations.runtimeClasspath.get().files.joinToString(&quot; &quot;) { &quot;./libs/${it.name}&quot; } }}tasks.register&lt;Copy&gt;(&quot;jar-dependency&quot;) { dependsOn(&quot;jar&quot;) from(configurations.runtimeClasspath) into(layout.buildDirectory.dir(&quot;libs/libs/&quot;))} 这样执行:./gradlew :jar-dependency 就会在build/lib目录生成一个xxx-palin.jar和一个libs文件夹 将这两个文件拷贝在一起,以使用java -jar xxx-plain.jar直接运行 方法二修改build.gradle.kts: 12345tasks.register&lt;Copy&gt;(&quot;jar-dependency&quot;) { dependsOn(&quot;jar&quot;) from(configurations.runtimeClasspath) into(layout.buildDirectory.dir(&quot;libs/libs/&quot;))} 这样执行:./gradlew :jar-dependency 就会在build/lib目录生成一个xxx-palin.jar和一个libs文件夹 将这两个文件拷贝在一起,可以使用java -cp &quot;alyze-1.0-plain.jar:libs/*&quot; your_main_class_name直接运行","link":"/2023/12/22/gradle-spring-boot-without-dependency/"},{"title":"ganesha编译以及使用vscode开发ganesha","text":"简介如何手动编译ganesha以及如何使用vscode远程开发ganesha源码 FSAL层使用cephfs 环境远程环境服务器: centos 7cmake版本: 3.12.3vscode版本: 1.88.0 配置编译环境下载源代码ganesha地址 1git clone https://github.com/nfs-ganesha/nfs-ganesha 编译的同时还需要ntirpc这个包里面的头文件,所以还需要初始化子模块 1git submodule --recursive --init 安装cmake由于centos7自带的cmake版本过低,需要手动安装较新的版本 Download CMake from: https://cmake.org/download/1wget https://cmake.org/files/v3.12/cmake-3.12.3.tar.gz Compile from source and install12345tar zxvf cmake-3.*cd cmake-3.*./bootstrap --prefix=/usr/localmake -j$(nproc)make install Validate installation123cmake --versioncmake version *.*.*CMake suite maintained and supported by Kitware (kitware.com/cmake). 安装ganesha编译所需依赖包12345# Common things # libcpefs-devel libcephfs2 这两个是fsal层使用ceph时需要用到的包，libcephfs2这个包如果没有的话，cephfs的一些功能可能无法使用yum install gcc git cmake autoconf libtool bison flex libacl-devel libcephfs-devel libtirpc rpcbind# More nfs-ganesha specificyum install libgssglue-devel openssl-devel nfs-utils-lib-devel doxygen redhat-lsb gcc-c++ 编译在ganesha源码的同级文件夹新建一个build目录ganesha是使用cmake来控制编译FSAL哪个模块的,由于我们是编译cephfs这个模块，所以要我修改一下cmake的命令 123456789101112131415161718192021222324cd build# 执行构建cmake \\ -DUSE_FSAL_PROXY_V4=OFF \\ -DUSE_FSAL_PROXY_V3=OFF \\ -DUSE_FSAL_VFS=ON \\ -DUSE_FSAL_LUSTRE=OFF \\ -DUSE_FSAL_LIZARDFS=OFF \\ -DUSE_FSAL_KVSFS=OFF \\ -DUSE_FSAL_CEPH=ON \\ -DUSE_FSAL_GPFS=OFF \\ -DUSE_FSAL_XFS=OFF \\ -DUSE_FSAL_GLUSTER=OFF \\ -DUSE_FSAL_NULL=OFF \\ -DUSE_FSAL_RGW=OFF \\ -DUSE_FSAL_MEM=OFF \\ -DUSE_9P=OFF \\ ../nfs-ganesha/src# 编译cmake --build . 如果不出意外的话，在当前build目录下应该会出现一个ganesha.nfsd可执行文件 测试编译结果在build同级目录,新建一个test目录 将编译结果复制到test目录1cp ../build/ganesha.nfsd ./ 复制配置文件：1cp ../nfs-ganesha/src/config_samples/ceph.conf ./ 复制并link so文件由于是使用ceph作为ganesha的后端,需要复制编译好的so文件: 123456cp ../build/FSAL/FSAL_CEPH/libfsalceph.so ./mkdir -p /usr/lib64/ganesha/ln -s [path]/libfsalcephs.so /usr/lib64/ganesha/ 修改一下配置文件如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221## It is possible to use FSAL_CEPH to provide an NFS gateway to CephFS. The# following sample config should be useful as a starting point for# configuration. This basic configuration is suitable for a standalone NFS# server, or an active/passive configuration managed by some sort of clustering# software (e.g. pacemaker, docker, etc.).## Note too that it is also possible to put a config file in RADOS, and give# ganesha a rados URL from which to fetch it. For instance, if the config# file is stored in a RADOS pool called &quot;nfs-ganesha&quot;, in a namespace called# &quot;ganesha-namespace&quot; with an object name of &quot;ganesha-config&quot;:## %url rados://nfs-ganesha/ganesha-namespace/ganesha-config## If we only export cephfs (or RGW), store the configs and recovery data in# RADOS, and mandate NFSv4.1+ for access, we can avoid any sort of local# storage, and ganesha can run as an unprivileged user (even inside a# locked-down container).#NFS_CORE_PARAM{ # Ganesha can lift the NFS grace period early if NLM is disabled. Enable_NLM = false; # rquotad doesn't add any value here. CephFS doesn't support per-uid # quotas anyway. Enable_RQUOTA = false; # In this configuration, we're just exporting NFSv4. In practice, it's # best to use NFSv4.1+ to get the benefit of sessions. Protocols = 4; # NFS_Port = 8088;}NFSv4{ # Modern versions of libcephfs have delegation support, though they # are not currently recommended in clustered configurations. They are # disabled by default but can be re-enabled for singleton or # active/passive configurations. # Delegations = false; # One can use any recovery backend with this configuration, but being # able to store it in RADOS is a nice feature that makes it easy to # migrate the daemon to another host. # # For a single-node or active/passive configuration, rados_ng driver # is preferred. For active/active clustered configurations, the # rados_cluster backend can be used instead. See the # ganesha-rados-grace manpage for more information. # RecoveryBackend = rados_ng; # NFSv4.0 clients do not send a RECLAIM_COMPLETE, so we end up having # to wait out the entire grace period if there are any. Avoid them. Minor_Versions = 1,2;}# The libcephfs client will aggressively cache information while it# can, so there is little benefit to ganesha actively caching the same# objects. Doing so can also hurt cache coherency. Here, we disable# as much attribute and directory caching as we can.MDCACHE { # Size the dirent cache down as small as possible. Dir_Chunk = 0;}EXPORT{ # Unique export ID number for this export Export_ID=100; # We're only interested in NFSv4 in this configuration Protocols = 4; # NFSv4 does not allow UDP transport Transports = TCP; # # Path into the cephfs tree. # # Note that FSAL_CEPH does not support subtree checking, so there is # no way to validate that a filehandle presented by a client is # reachable via an exported subtree. # # For that reason, we just export &quot;/&quot; here. Path = /; # # The pseudoroot path. This is where the export will appear in the # NFS pseudoroot namespace. # # Pseudo = /cephfs_a/; Pseudo = /cephfs_a; # We want to be able to read and write Access_Type = RW; # Time out attribute cache entries immediately Attr_Expiration_Time = 0; # Enable read delegations? libcephfs v13.0.1 and later allow the # ceph client to set a delegation. While it's possible to allow RW # delegations it's not recommended to enable them until ganesha # acquires CB_GETATTR support. # # Note too that delegations may not be safe in clustered # configurations, so it's probably best to just disable them until # this problem is resolved: # # http://tracker.ceph.com/issues/24802 # # Delegations = R; # NFS servers usually decide to &quot;squash&quot; incoming requests from the # root user to a &quot;nobody&quot; user. It's possible to disable that, but for # now, we leave it enabled. Squash = root; FSAL { # FSAL_CEPH export Name = CEPH; # # Ceph filesystems have a name string associated with them, and # modern versions of libcephfs can mount them based on the # name. The default is to mount the default filesystem in the # cluster (usually the first one created). # Filesystem = &quot;cephfs&quot;; # # Ceph clusters have their own authentication scheme (cephx). # Ganesha acts as a cephfs client. This is the client username # to use. This user will need to be created before running # ganesha. # # Typically ceph clients have a name like &quot;client.foo&quot;. This # setting should not contain the &quot;client.&quot; prefix. # # See: # # http://docs.ceph.com/docs/jewel/rados/operations/user-management/ # # The default is to set this to NULL, which means that the # userid is set to the default in libcephfs (which is # typically &quot;admin&quot;). # # User_Id = &quot;ganesha&quot;; # # Key to use for the session (if any). If not set, it uses the # normal search path for cephx keyring files to find a key: # # Secret_Access_Key = &quot;YOUR SECRET KEY HERE&quot;; }}# Config block for FSAL_CEPHCEPH{ # Path to a ceph.conf file for this ceph cluster. Ceph_Conf = /etc/ceph/ceph.conf; # User file-creation mask. These bits will be masked off from the unix # permissions on newly-created inodes. # umask = 0;}## This is the config block for the RADOS RecoveryBackend. This is only# used if you're storing the client recovery records in a RADOS object.#RADOS_KV{ # Path to a ceph.conf file for this cluster. # Ceph_Conf = /etc/ceph/ceph.conf; # The recoverybackend has its own ceph client. The default is to # let libcephfs autogenerate the userid. Note that RADOS_KV block does # not have a setting for Secret_Access_Key. A cephx keyring file must # be used for authenticated access. # UserId = &quot;ganesharecov&quot;; # Pool ID of the ceph storage pool that contains the recovery objects. # The default is &quot;nfs-ganesha&quot;. # pool = &quot;nfs-ganesha&quot;; pool = cephfs_data; # Consider setting a unique nodeid for each running daemon here, # particularly if this daemon could end up migrating to a host with # a different hostname (i.e. if you're running an active/passive cluster # with rados_ng/rados_kv and/or a scale-out rados_cluster). The default # is to use the hostname of the node where ganesha is running. # nodeid = hostname.example.com nodeid = node1;}# Config block for rados:// URL access. It too uses its own client to access# the object, separate from the FSAL_CEPH and RADOS_KV client.RADOS_URLS{ # Path to a ceph.conf file for this cluster. # Ceph_Conf = /etc/ceph/ceph.conf; # RADOS_URLS use their own ceph client too. Authenticated access # requires a cephx keyring file. # UserId = &quot;ganeshaurls&quot;; # We can also have ganesha watch a RADOS object for notifications, and # have it force a configuration reload when one comes in. Set this to # a valid rados:// URL to enable this feature. # watch_url = &quot;rados://pool/namespace/object&quot;;}# 日志LOG{ COMPONENTS{ ALL = FULL_DEBUG; }} 启动执行一下命令，如果不出意外的话就可以启动了：日志会输出在当前目录的log文件中 1./ganesha.nfsd -f ceph.conf -F -L log 挂载在另一台机器进行挂载: 1mount -t nfs -o nfsvers=4.1,proto=tcp &lt;ganesha-host-name&gt;:&lt;ganesha-pseudo-path&gt; &lt;mount-point&gt; vscode 配置远程开发下载插件Remote Development 配置免密登陆配置密钥如果没有ssh密钥，执行百度生成一份 1ssh-copy-id ${username}@${host} 配置ssh的config文件1vim ~/.ssh/config 添加一行配置： 12345678# 缩写Host # ip或者hostnameHostName 192.168.101.121Port 22PreferredAuthentications publickeyUser userIdentityFile ~/.ssh/id_rsa 连接配置上以上流程，这时打开vscode，cmd+shit+p就可以看到你要链接远程的机器 安装必要的插件一下插件都是在远程安装的 C/C++ CMake 配置vscodec_cpp_properties.json在.vscode目录下新建文件： c_cpp_properties.json 内容如下： 1234567891011121314151617181920{ &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Linux&quot;, # 这里很重要，主要是配置那些路径被include进来，可以减少报错 &quot;includePath&quot;: [ &quot;${workspaceFolder}/build/include/**&quot;, &quot;${workspaceFolder}/src/**&quot;, &quot;/usr/include/**&quot;, &quot;/usr/include&quot; ], &quot;defines&quot;: [], &quot;compilerPath&quot;: &quot;/usr/bin/gcc&quot;, &quot;cStandard&quot;: &quot;c11&quot;, &quot;cppStandard&quot;: &quot;c++14&quot;, &quot;intelliSenseMode&quot;: &quot;${default}&quot; } ], &quot;version&quot;: 4} settings.json在.vscode目录下新建文件： settings.json 内容如下： 12345678910111213141516171819202122232425262728{ &quot;cmake.sourceDirectory&quot;: &quot;/root/nfs-ganesha-code/nfs-ganesha/src&quot;, &quot;cmake.options.statusBarVisibility&quot;: &quot;visible&quot;, &quot;files.associations&quot;: { &quot;config.h&quot;: &quot;c&quot;, &quot;nfs4.h&quot;: &quot;c&quot;, &quot;signal.h&quot;: &quot;c&quot;, &quot;internal.h&quot;: &quot;c&quot; }, &quot;C_Cpp.default.configurationProvider&quot;: &quot;ms-vscode.cmake-tools&quot;, # 这里就是控制编译那些选项 &quot;cmake.configureArgs&quot;: [ &quot;-DUSE_FSAL_PROXY_V4=OFF&quot;, &quot;-DUSE_FSAL_PROXY_V3=OFF&quot;, &quot;-DUSE_FSAL_VFS=ON&quot;, &quot;-DUSE_FSAL_LUSTRE=OFF&quot;, &quot;-DUSE_FSAL_LIZARDFS=OFF&quot;, &quot;-DUSE_FSAL_KVSFS=OFF&quot;, &quot;-DUSE_FSAL_CEPH=ON&quot;, &quot;-DUSE_FSAL_GPFS=OFF&quot;, &quot;-DUSE_FSAL_XFS=OFF&quot;, &quot;-DUSE_FSAL_GLUSTER=OFF&quot;, &quot;-DUSE_FSAL_NULL=OFF&quot;, &quot;-DUSE_FSAL_RGW=OFF&quot;, &quot;-DUSE_FSAL_MEM=OFF&quot;, &quot;-DUSE_9P=OFF&quot; ]} 验证是否配置成功点击左侧的cmake插件，点击build,如果能成功的build,就是成功，如果不能，执行根据报错排查","link":"/2024/04/16/how-to-compile-ganesha/"},{"title":"手把手教你开发一个neovim插件","text":"开篇废话使用neovim久了,使用了众多插件,不自己开发一个插件,怎么好标榜自己是一个vimer?今天老夫就手把手教大家开发一个自己的neovim插件 项目结构与插件路径插件路径这里差不多也是废话,理论上来说,vim的插件可以在任何位置,插件的方式也可以是各种形式,不过为了这里面还是有一些潜规则的.首先就是插件的路径,一般来说,neovim会默认加载一些路径,可以在neovim中执行echo &amp;rtp(rtp:runtime path)来查看默认的加载路径有哪些,不过由于我们是自己开发的插件,就暂时不要放在这些路径里面了,避免启动时报错,假设我现在放在了~/temp/neovim/lua/lowb这个目录下进行开发lowb插件,然后在启动neovim的时候使用nvim --cmd &quot;set rtp+=~/temp/neovim&quot;启动就可以加载lowb插件了,插件名就是lua路径下的文件夹名,如果你的插件比较简单,可以不用新建一个文件夹,直接搞一个lowb.lua就可以加载了,不过按照约定一般是有一个文件夹的,方便发布,供其他人使用 这里需要注意,一定放在lua的子目录下,否则neovim是不会进行加载这个插件的,参考 项目结构init.luaneovim会自动加载目录下的init.lua作为neovim的默认加载文件 开始开发加载确定了插件路径和项目结构,就可以开发lowb插件了,在~/temp/neovim/lua/lowb,先新建一个init.lua文件,文件内容如下: 1print(&quot;Hello lowb&quot;) 然后使用nvim -c &quot;set rtp+=~/temp/neovim&quot;启动neovim 进入neovim的命令模式执行:lua require('lowb')可以看到会打印Hello lowbOK,现在插件成功加载了 导出函数插件肯定不能简单的加载,还要导出一些函数供用户使用,更新init.lua 123456local M = {}function M.say_lowb() print(&quot;hello lowb&quot;)endreturn M 保存插件,重新使用命令nvim -c &quot;set rtp+=~/temp/neovim&quot;启动neovim进入neovim的命令模式执行:lua require('lowb').say_lowb() 现在lowb插件基本完成,还有一项功能就是给用户设置的能力 setup函数neovim插件一般是通过向外暴露一个setup函数来给用户设定,这倒不是强制规定,只是一个默认约定,像一些插件管理工具,比如lazy.vim一般就是默认使用setup来进行初始化插件, 现在再改一下init.lua文件 12345678910111213141516171819local default_config = { name = &quot;狗蛋&quot;}local M = { config = default_config}function M.say_lowb() print(&quot;hello lowb &quot;..M.config.name)endfunction M.setup(config) M.config = config vim.print(M)endreturn M 保存退出,重新使用命令:nvim -c &quot;set rtp+=~/temp/neovim&quot; 启动neovim, 进入命令模式执行以下命令 12lua require('lowb').setup({name=finger})lua require('lowb').say_lowb() 就会看到打印的信息从”狗蛋”更新为”finger” 现在一个简单的neovim插件就开发完成了,至于能做什么 想象力越大,能力越大","link":"/2023/10/12/how-to-develope-a-neovim-plugin/"},{"title":"idea怎么在project 选项卡中隐藏特定的文件和文件夹","text":"在日常使用idea项目开发中,有些文件或者文件夹不想在project选项卡中显示,想要隐藏掉,隐藏方法: File -&gt; Settings -&gt; Editor -&gt; File Types -&gt; Ignore Files And folders","link":"/2023/10/13/idea-how-to-hide-folder-in-project/"},{"title":"java byte array 转String在转回byte array不相等","text":"背景最近在搞微软的NBFS协议,这个协议实际上也是基于WebService,只不过对xml进行了压缩,按照他自己的编码规则进行压缩网上搜罗一圈后发现有个大佬写好的burp的NBFS插件WCF-Binary-SOAP-Plug-In这个插件会将传入的经过base64编码的xml转换成NBFS协议的base64编码的字符串 测试那边要使用jmeter对这个NBFS接口性能测试基本思路: 新建http request输入原始的xml 搞一个PreProcessor,调用大佬写的NBFS.exe获取压缩后的XMLbase64编码的字符串 PreProcessor 代码如下 12345678910111213141516171819import org.apache.commons.codec.binary.Base64;// 获取请求体数据def requestBody = sampler.getArguments().getArgument(0).getValue();// 检查请求体是否存在if (requestBody != null) { log.info(&quot;获取到请求体:{}&quot;,requestBody) // 进行加密操作，这里使用Base64编码作为示例 def reqBase64Str = Base64.encodeBase64String(requestBody.getBytes()); def process = Runtime.getRuntime().exec(&quot;./NBFS.exe&quot;,&quot;encode&quot;,reqBase64Str) process.waitFor() def nbfsEncodeBase64Str = process.inputStream.text def result = Base64.decodeBase64(nbfsEncodeBase64Str) // 将加密后的数据设置回请求体 sampler.getArguments().getArgument(0).setValue(new String(result));} else { log.warn(&quot;请求体不存在&quot;);} 这时候就会发现一个神奇的东西,接口会返回400错误 问题分析先说明下NBFS编码的原理,为了压缩xml,NBFS会预先定义一些字典,比如:0x90代表Reason这个字符,也就是说,经过NBFS.exe返回的Base64字符串经过Base64.decodeBase64(nbfsEncodeBase64Str)这个方法返回的byte数组中可能出现0x80,0xAA等字节 众所周知,java默认的字符串编码是UTF-8 另一个常识是:java字符串是由Char[]表示的,而Char是由unicode表示 ok,有了上面的已知条件,返回400的问题,就是解释为什么下面代码输出是false就行了 1234byte[] byteArray = new byte[]{0x01, (byte)0x81, (byte)0xAA, 0x44, 0x45};String str = new String(byteArray);byte [] revertByteArray = str.getBytes();System.out.println(Arrays.equals(byteArray,revertByteArray)); 其实断点调试下,会发现其实revertByteArray这个数组其实是:[1, -17, -65, -67, -17, -65, -67, 68, 69]而原数组是:[1, -128, -86, 68, 69]区别就是多出了6个byte,其中0x81,0xAA对应变成[-17,-65,-67],对应10进制的65533,对应的unicde就是:\\uFFFD 接下来就分析一下为什么0x81为什么会变成[-17,-65,-67]这玩意就行了 debug大法对new String(byteArr)这段代码开始debug,就会发现最终会进入一个超长的方法: sun.nio.cs.UTF_8.Decoder#decode: 123456789101112131415161718192021222324252627282930313233343536373839404142434445// da 就是字符串找保存的char[]// sa 就是String构造函数传进来的byte 数组// 就是这个方法将byte [] -&gt; char []// sp 是0,应该是偏移量, String str = new String(byteArray,1,1,&quot;UTF-8&quot;);这么创建字符串才会有,这个不重要,// len就是byte数组的长度public int decode(byte[] sa, int sp, int len, char[] da) { final int sl = sp + len; int dp = 0; int dlASCII = Math.min(len, da.length); ByteBuffer bb = null; // only necessary if malformed // ASCII only optimized loop //性能优化,&gt;= 0的意思就是byte没有溢出,也就是:0~128,对应就是0x00 到 0x00 0x80 while (dp &lt; dlASCII &amp;&amp; sa[sp] &gt;= 0) da[dp++] = (char) sa[sp++]; //下面就是范围判断,判断byte是否在utf8的编码范围内 while (sp &lt; sl) { int b1 = sa[sp++]; if (b1 &gt;= 0) { // 1 byte, 7 bits: 0xxxxxxx da[dp++] = (char) b1; } else if ((b1 &gt;&gt; 5) == -2 &amp;&amp; (b1 &amp; 0x1e) != 0) { // 2 bytes, 11 bits: 110xxxxx 10xxxxxx . . . } else if ((b1 &gt;&gt; 4) == -2) { // 3 bytes, 16 bits: 1110xxxx 10xxxxxx 10xxxxxx . . . } else if ((b1 &gt;&gt; 3) == -2) { // 4 bytes, 21 bits: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx . . . } else { if (malformedInputAction() != CodingErrorAction.REPLACE) return -1; da[dp++] = replacement().charAt(0); } } return dp; } 上面代码翻译成人话就是:循环byte数组里面的每一个byte 如果&gt;=0,就是ASCII 如果不是,判断是否符合条件: 1 byte, 7 bits: 0xxxxxxx 2 bytes, 11 bits: 110xxxxx 10xxxxxx 3 bytes, 16 bits: 1110xxxx 10xxxxxx 10xxxxxx 4 bytes, 21 bits: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 如果都不符合,就返回replacement()第0个char(打断点看,这个字符其实就是main类启动时创建的,其实这就是’65533’也就是\\uFFFD) 至此,真相大白 0x80-&gt;0b100000000x88-&gt;0b10010000 都不在上面的范围,所以他们最终的char最终都会变成65533(\\uFFFD) 其实上面的规则就是UTF-8规则,参考维基百科: 在ASCII码的范围，用一个字节表示，超出ASCII码的范围就用字节表示，这就形成了我们上面看到的UTF-8的表示方法，这样的好处是当UNICODE文件中只有ASCII码时，存储的文件都为一个字节，所以就是普通的ASCII文件无异，读取的时候也是如此，所以能与以前的ASCII文件兼容。 大于ASCII码的，就会由上面的第一字节的前几位表示该unicode字符的长度，比如110xxxxx前三位的二进制表示告诉我们这是个2BYTE的UNICODE字符；1110xxxx是个三位的UNICODE字符，依此类推；xxx的位置由字符编码数的二进制表示的位填入。越靠右的x具有越少的特殊意义。只用最短的那个足够表达一个字符编码数的多字节串。注意在多字节串中，第一个字节的开头”1”的数目就是整个串中字节的数目。 太长不看一句话总结:因为类似0x80,0x88等字节不在utf-8编码范围内,所以会返回一个默认字符,\\uFFFD(65533),这个字符占3个字节,所以就造成的两个byte数组不相等 解决方法解决方法很简单:找一个编码覆盖0x00 到 0xff,并且只用一个字节编码的编码格式就行,没错,就是你-ISO-8859-1! 所以下面代码输出就是true 123456byte[] byteArray = new byte[]{0x01, (byte)0x81, (byte)0xAA, 0x44, 0x45};String str = new String(byteArray,&quot;ISO-8859-1&quot;);byte [] revertByteArray = str.getBytes(&quot;ISO-8859-1&quot;);System.out.println(Arrays.equals(byteArray,revertByteArray));","link":"/2023/09/21/java-byte-convert-string-not-equal/"},{"title":"idea下配置vim模式","text":"vim搓一切?有一说一,vim虽然可以配置的很舒服,但是对于java程序员来说,用vim去写java是真的折磨,除非你想进行自我折磨,变成代码仙人.所以最省心的方案就是在idea中下一个vim插件 安装首先你要有一个 java第一 IDE:intellij idea然后打开插件市场,下一个idea vimrc 安装上 配置.ideavimrc 创建一个~/.ideavimrc 加入一些配置: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156&quot; ____ _ ____ ___ ____&quot; | __ ) / \\ / ___| |_ _| / ___|&quot; | _ \\ / _ \\ \\___ \\ | | | |&quot; | |_) | / ___ \\ ___) | | | | |___&quot; |____/ /_/ \\_\\ |____/ |___| \\____|&quot; 上下预留5行set so=5&quot; 不折叠 set nowrap&quot; 去掉哔哔声set belloff=allset noerrorbellsset t_vb=set backspace=indent,eol,start whichwrap+=&lt;,&gt;,[,]&quot; Vim 的默认寄存器和系统剪贴板共享set clipboard+=unnamedplusset keep-english-in-normal&quot; 开启相对行set relativenumberset nuset ignorecaseset smartcase&quot; ____ _ _ _ ____ ___ _ _&quot; | _ \\ | | | | | | / ___| |_ _| | \\ | |&quot; | |_) | | | | | | | | | _ | | | \\| |&quot; | __/ | |___ | |_| | | |_| | | | | |\\ |&quot; |_| |_____| \\___/ \\____| |___| |_| \\_|&quot;&quot;&quot;开启多光标支持Plug 'machakann/vim-highlightedyank'Plug 'vim-scripts/argtextobj.vim'Plug 'justinmk/vim-sneak'Plug 'easymotion/vim-easymotion'Plug 'unblevable/quick-scope'Plug 'preservim/nerdtree'Plug 'tpope/vim-commentary'&quot;USAGE &quot; add surround&quot; ys{textobject motion}{indeifier}&quot; eg:&quot; ysiw'&quot;&quot; remove surround &quot; ds'&quot;&quot; change surround &quot; cs[(Plug &quot;tpope/vim-surround&quot;&quot;USAGE &quot; [count][&quot;x]gr{motion} Replace {motion} text with the contents of register x.&quot; Especially when using the unnamed register, this is&quot; quicker than &quot;_d{motion}P or &quot;_c{motion}&lt;C-R&gt;&quot;&quot; [count][&quot;x]grr Replace [count] lines with the contents of register x.&quot; To replace from the cursor position to the end of the&quot; line use [&quot;x]gr$&quot; {Visual}[&quot;x]gr Replace the selection with the contents of register x.&quot;Plug 'vim-scripts/ReplaceWithRegister'&quot; USAGE &quot; cx&quot; On the first use, define the first {motion} to exchange. On the second use, define the second {motion} and perform the exchange.&quot;&quot; cxx&quot; Like cx, but use the current line.&quot;&quot; X&quot; Like cx, but for Visual mode.&quot;&quot; cxc&quot; Clear any {motion} pending for exchange.&quot;Plug 'tommcdo/vim-exchange'Plug 'terryma/vim-multiple-cursors'&quot; quick-scop cofniglet g:qs_highlight_on_keys = ['f', 'F', 't', 'T']let g:qs_accepted_chars = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'] &quot; https://github.com/JetBrains/ideavim/wiki/ideajoin-examplesset ideajoinset sneak&quot; _ __ _____ __ __ __ __ _ ____&quot; | |/ / | ____| \\ \\ / / | \\/ | / \\ | _ \\&quot; | ' / | _| \\ V / | |\\/| | / _ \\ | |_) |&quot; | . \\ | |___ | | | | | | / ___ \\ | __/&quot; |_|\\_\\ |_____| |_| |_| |_| /_/ \\_\\ |_|&quot; basic key map inoremap &lt;C-e&gt; &lt;END&gt;inoremap &lt;C-a&gt; &lt;HOME&gt;inoremap &lt;C-f&gt; &lt;Right&gt;inoremap &lt;C-b&gt; &lt;Left&gt;inoremap &lt;C-n&gt; &lt;Down&gt;inoremap &lt;C-p&gt; &lt;Up&gt;inoremap &lt;M-f&gt; &lt;S-Right&gt;inoremap &lt;M-b&gt; &lt;S-Left&gt;inoremap &lt;C-k&gt; &lt;ESC&gt;d$iinoremap &lt;C-d&gt; &lt;Del&gt;let mapleader=&quot; &quot;&quot; idea action confignnoremap gd &lt;Action&gt;(GotoDeclaration)nnoremap gi &lt;Action&gt;(GotoImplementation)nnoremap gs &lt;Action&gt;(GotoSuperMethod)nnoremap gt &lt;Action&gt;(GotoTypeDeclaration)map &lt;leader&gt;re &lt;Action&gt;(RenameElement)map &lt;leader&gt;gf &lt;Action&gt;(GotoFile)map &lt;leader&gt;gt &lt;Action&gt;(GotoSymbol)map &lt;leader&gt;f: &lt;Action&gt;(GotoAction)map &lt;leader&gt;f. &lt;Action&gt;(FindInPath)map &lt;leader&gt;fl &lt;Action&gt;(RecentLocations)map &lt;leader&gt;ff &lt;Action&gt;(RecentFiles)map &lt;leader&gt;et :NERDTreeToggle&lt;CR&gt;map &lt;leader&gt;ef :NERDTreeFocus&lt;CR&gt;map &lt;leader&gt;es &lt;Action&gt;(FileStructurePopup)nmap &lt;C-W&gt;q &lt;Action&gt;(CloseAllEditors)&quot; plugin config let g:multi_cursor_use_default_mapping=0&quot; Default mappinglet g:multi_cursor_start_word_key = '&lt;C-n&gt;'let g:multi_cursor_select_all_word_key = '&lt;A-n&gt;'let g:multi_cursor_start_key = 'g&lt;C-n&gt;'let g:multi_cursor_select_all_key = 'g&lt;A-n&gt;'let g:multi_cursor_next_key = '&lt;C-n&gt;'let g:multi_cursor_prev_key = '&lt;C-p&gt;'let g:multi_cursor_skip_key = '&lt;C-x&gt;'let g:multi_cursor_quit_key = '&lt;Esc&gt;' 让其生效打开idea,source一下 1source ~/.ideavimrc FBI WARNING .ideavimrc里面有一些插件是要在idea中也要下载对应的插件才能使用的,具体参考这里 map &lt;leader&gt;f: &lt;Action&gt;(GotoAction) 这种形式是在调用idea的原生功能,具体有哪些功能,可以参考这里,可以打开ideavim的插件,查看对应操作的&lt;ActionId&gt;","link":"/2023/09/22/intellij-idea-config-vim/"},{"title":"linux下安装多版本jdk并进行切换","text":"背景进行程序升级的时候,可能要在服务器上安装多个版本的jdk并且进行切换,我在本机使用的是asdf,这个东西用来管理多版本还是挺香的,不过由于服务器无法访问国际互联网,只能寻找其他替代方案. alternativesalternatives是linux系统中一个十分强大的命令(此句是废话,linux每个命令都很强大),主要功能就是为了解决,系统中有类似的命令,给用户一个选择的方式,在多个jdk的切换就很有用,可以在多个jdk版本切换 配置删除原来的内容如果你原来配置jdk方式是通过修改环境变量来实现的,要现去除掉这个配置,一般在/etc/profile或者/etc/environment或者~/.bash_profile这几个文件中,将原来的配置删除掉 12345# 全部注释掉#export JAVA_HOME=/var/local/jdk1.8.0_202#export JRE_HOME=${JAVA_HOME}/jre#export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib#export PATH=${JAVA_HOME}/bin:$PATH 然后执行source /etc/profile生效,如果不生效就重新登录下.这部完成后,再验证下,exho $PATH,看下java命令是不是在PATH中 使用laternatives配置jdk删除掉原来的配置后,就可以使用alternatives来配置java命令了,找到你两个jdk的位置,然后执行一下命令: 12345sudo alternatives --install /usr/bin/java java /opt/jdk1.8.0_301/bin/java 1sudo alternatives --install /usr/bin/javac javac /opt/jdk1.8.0_301/bin/javac 1sudo alternatives --install /usr/bin/java java /opt/jdk-11.0.12/bin/java 2sudo alternatives --install /usr/bin/javac javac /opt/jdk-11.0.12/bin/javac 2 切换jdk后面如果想切换java版本,就可以使用命令: 12345678910$ alternatives --config javaThere are 2 programs which provide 'java'. Selection Command----------------------------------------------- 1 /var/local/jdk1.8.0_202/bin/java*+ 2 /usr/local/jdk-11/bin/javaEnter to keep the current selection[+], or type selection number: 输入一个序号就完成java版本的切换了","link":"/2024/01/05/linux-multi-jdk-config/"},{"title":"macos下,实现vim切换模式自动切换输入法","text":"macos下,实现vim切换模式自动切换输入法作为一个重度vim模式使用用户,切换模式输入法不自动切换一直是一个蛋疼的问题,目前主要解决方案就是使用im-select,在对应使用的应用里面设置im-select的路径但是这种方式有一个问题就是如果应用不支持,就不会自动切换 另一种方式就是使用rime输入法,但是对于我来说配置成本太高,不划算. 经过我的研究,发现karabiner可以实现在任意应用中使用vim,按下对应的模式切换键实现自动切换输入法. 安装karabinerkarabiner是mac下一个按键功能映射的软件,可以自己定义json文件实现许多复杂的功能的映射 brew不解释连招 1brew install karabiner 安装im-select继续brew不解释连招 1brew install im-select 创建映射文件/Users/fingerfrings/.config/karabiner/assets/complex_modifications路径创建一个vim-esc.json文件 文件内容如下: 123456789101112131415161718192021222324252627{ &quot;title&quot;: &quot;Vim shortcuts&quot;, &quot;rules&quot;: [ { &quot;description&quot;: &quot;Map ^+[ to esc&quot;, &quot;manipulators&quot;: [ { &quot;type&quot;: &quot;basic&quot;, &quot;from&quot;: { &quot;key_code&quot;: &quot;open_bracket&quot;, &quot;modifiers&quot;: { &quot;mandatory&quot;: [&quot;control&quot;] } }, &quot;to&quot;: [ { &quot;key_code&quot;: &quot;escape&quot; },{ &quot;shell_command&quot;: &quot;/usr/local/bin/im-select com.apple.keylayout.ABC&quot; } ] } ] }, ]} 上面文件的映射内容就是将Ctrl-[映射为Esc,同时执行/usr/local/bin/im-select com.apple.keylayout.ABC命令 设置karabiner在complex Modifications选项中启用Map ^+[ to esc 参考文档https://karabiner-elements.pqrs.org/docs","link":"/2023/09/20/macos-vim-auto-change-input-method/"},{"title":"neovim配置formatters","text":"最近再搞vue3,使用了element plus admin这个模版库,没想到一直报错后来经过排查发现是这个模板库使用了prettier这位lint的配置项,简单来说就是如果不符合他的格式就会报错,而我的neovim是使用的volar这个lsp作为格式化话的后端,想要保存自动安装prettier的格式格式化,需要额外加一些配置 本来是想打算用null-ls,因为更符合哲学的,其实就是将一些formatter作为neovim原生的lspinject进去不过这个项目目前停更了,而且我也只是想保存的时候格式化就行了,所以就选择了另一个插件formatter.nvim 安装安装prettier在mason中找到prettier安装就行不过这个地方比较有意思,mason其实是安装了prettier的,按时我在终端中缺无法使用,后来发现mason安装的工具其实是在~/.local/share/nvim/mason/bin/里面,然后在放到neovim内置的环境变量中是,在neovim的命令模式执行:!env就可以看到 安装formatter.nvim 12345678910111213141516171819202122{ &quot;mhartington/formatter.nvim&quot;, name = &quot;formatter&quot;, event = &quot;BufEnter&quot;, enabled = true, # 这个配置一定要写到config选项中,不然会报错 config = function(LazyPlugin,opts) local opts = { logging = true, log_level = vim.log.levels.WARN, filetype = { vue = { require(&quot;formatter.filetypes.vue&quot;).prettier(), _ } } } require(&quot;formatter&quot;).setup(opts) end } 这里需要注意的点是 formatter并没用给默认的格式化配置,所以没中文件都要配置 配置想要写到lazyvim的config选项中,不然会提示找不到formatter.filetypes.vue 保存自动格式化1vim.api.nvim_create_autocmd({&quot;BufWritePost&quot;},{pattern = {&quot;*&quot;},command = &quot;FormatWrite&quot;}) 原理formatter.nvim相当于一个接口,然后自己配置格式化命令,当执行格式化命令时,会调用你配置的格式化命令,如果不配置就是使用默认的,想上面的vue执行格式化的时候其实就是在执行默认的格式化,约等于下面的伪代码: 1prettier --stdin-filepath %","link":"/2023/11/01/neovim-config-formatter/"},{"title":"管道操作符和xargs的区别","text":"之前一直没有理解shell中管道操作符和xargs的区别,为什么有一些命令要用可以直接用管道操作符链接,为什么一些需要加个xargs,最近翻了一些文档之后,终于理解 官方定义最好的解释永远来自于官方文档,正所谓真传一句话,假传万卷书. 管道操作符A pipeline is a sequence of one or more commands separated by one of the control operators ‘|’ or ‘|&amp;’.The output of each command in the pipeline is connected via a pipe to the input of the next command. That is, each command reads the previous command’s output. This connection is performed before any redirections specified by command1. 简单来说就是,管道操作符连接一系列命令,前面的标准输出作为后面的标准输入 xargsThe xargs utility reads space, tab, newline and end-of-file delimited strings from the standard input and executes utility with the strings as arguments.Any arguments specified on the command line are given to utility upon each invocation, followed by some number of the arguments read fromthe standard input of xargs. This is repeated until standard input is exhausted. Spaces, tabs and newlines may be embedded in arguments using single ( ' '') or double (“‘’) quotes or backslashes (``'‘). Singlequotes escape all non-single quote characters, excluding newlines, up to the matching single quote. Double quotes escape all non-doublequote characters, excluding newlines, up to the matching double quote. Any single character, including newlines, may be escaped by abackslash. 简单来说,就是xargs是从标准输入读取内容,作为xrags命令后面跟的命令的参数 举个例子管道操作符1echo &quot;hello \\n world&quot; | grep hello echo &quot;hello world&quot; 会将hello world字符串输出到标准输出,然后通过管道操作符作为 grep hello这条命令的标准输入 上面的命令相当于下面的命令 1234grep hello # 执行完按回车hello # 输入hello worldhello # 打印helloworld # 输入world 什么也不打印 xargs12xargs ls #按回车/usr #按ctrl-d 会打印/usr目录下的所有文件 ctrl-d相当于向shell输入了一个eof,表示输入完成 组合这两个命令一般是组合使用 比如: 1cat a.txt | xargs mkdir -p 这条命令的含义是,将a.ext文件中的内容作为文件夹名,新建一个文件夹其中,cat a.txt命令是将a.txt中的内容输出到标准输出,然后通过管道操作符作为xargs mkdir -p这个命令的标准输入,xargs将前面传过来的标准输入作为mkdir -p 这条命令的参数 标准输入/标准输出/参数在linux中,默认情况下 标准输入是指键盘标准输出是指屏幕参数就是命令后面跟着的内容 举个例子12345$ cat hello-world.txt # hello-world.txt 是参数$ cat #执行cat命令后回车$ hello #输入hello 这里的hello就是标准输入$ hello # 命令行打印hello 这里打印的hello就是找女友输入","link":"/2023/10/31/shell-pipeline-and-xargs/"},{"title":"终端下常用快捷键汇总","text":"说明其实大部分都是emacs的快捷键,终端也可以切换为vim模式,快捷键就会有变化 C : CtrlA : ALT 光标移动 快捷键 效果 C-a 移动到行首 C-e 移动到行尾 C-f 向后移动一个字符 C-b 向前移动一个字符 C-xx 在行首和当前光标位置之间互相切换 A-f / ESC-f 向后移动一个单词 A-b / ESC-b 向前移动一个单词 控制和处理流程 快捷键 效果 C-l 清除命令行历史输出 C-z 挂起当前程序 C-q 回复挂起的程序 C-i 等于tab C-j 等于enter 编辑 快捷键 效果 C-d 删除后一个字符 C-h 删除光标钱一个字符 C-k 从光标删除到行尾 C-u 从光标删除到行首 C-w 删除光标前的一个单词 A-t / Esc-t 替换当前光标的单词和前一个单词的位置 历史相关的 快捷键 效果 C-r 搜索历史 C-p 上一条命令 C-n 下一条命令","link":"/2023/09/24/terminal-shortcuts/"},{"title":"使用asdf管理你的sdk","text":"对于我这种使用多种语言开发,并且可能在给个版本之前来回切换的人来说,一直渴望一个好的sdk管理工具举个具体的例子:有两个项目,一个项目使用jdk-8另一个项目使用jdk-17,在ide里面还好说,毕竟可选择,但是当你在命令行里面操作时,来回切换jdk有多难受就不必我多说了吧而且如果要用两个jdk,这两个就要使用HomeBrew安装两个jdk,而且安装的路径还不一样 除此之外,还有前端的node版本,不同的项目使用的NodeJs版本不同,换来换区也是麻烦的不行 这个时候就体现了asdf这个工具的方便之处, 如果使用来asdf,那么安装和切换jdk的版本就会如此美妙 现在假设在使用asdf的情况下,如果有两个项目a 和 b,分别使用jdk-8和jdk-17,那么管理的流程就是如下的 安装对应的jdk:asdf install java openjdk-8, asdf install java openjdk-17 分别进入a和b两个目录,执行asdf local java openjdk-8,asdf local java openjdk-17 这个时候,当你在命令行进入对应的项目,你执行java -version就会对应不同的jdk版本 而且安装的jdk统一的都在~/.asdf.plugins/java目录下,丝毫不会污染你其他的目录,干净又卫生了属于是 下面简单说下安装以及使用,基本上是官方文档内容 安装我是使用HomeBrew安装 123brew install asdfecho -e &quot;\\n. $(brew --prefix asdf)/libexec/asdf.sh&quot; &gt;&gt; ${ZDOTDIR:-~}/.zshrc 使用(以java为例)plugin在asdf的语义中,plugin就是帮你管理对应语言sdk的模块,比如你需要下载是管理java的版本,你就需要下载对应的java plugin 搜索plugin1asdf plugin list all | grep java 安装plugin1asdf plugin add java 安装sdk12345678910# 搜索jdkasdf list all java | grep jdk # 安装jdk # 安装指定版本asdf install java openjdk-17.0 # 安装指定版本的最新版本asdf install java openjdk-17:latest # 安装最新稳定版asdf install java latest 设置1234# 设置命令行使用的版本asdf global java openjdk-17# 设置当前路径使用的jdk版本,会在当前目录下生成一个.tool-versions文件asdf local java openjdk-17 其他常用命令12345678910111213141516# 查看当前各个sdk的版本asdf current# 查看当前java使用的sdk版本asdf current java# 查看安装那些pluginasdf plugin list# 查看当前使用的java 命令的路径asdf which java# 查看当前使用的java sdk的路径asdf where java# 移除对应的sdkasdf uninstall java openjdk-17# 移除对应的pluginasdf plugin remove java# 更新(所有)pluginasdf plugin update [--all] 参考资料asdf官方文档","link":"/2023/09/26/use-asdf-manage-sdk/"},{"title":"vscode更好用的vim插件","text":"前言对我来说,使用vim后有两个后遗症,一是想把vim配置的全知全能,二是在任何软件中都想启用vim模式,现在前者的症状已经有所减轻,后者愈发严重 更好用的vim插件之前在 vscode中使用的 vim插件一直是vim,但是这个插件有一个让我非常苦恼的问题,就是这个插件没有neovim中的flash插件,它默认的快速移动插件是easymotion,个人觉得,easymotion这个插件的已送快捷键方式实在是太不方便,举个简单的例子:他的prefix是要按两下leader按键,而flash插件就十分的方便,按下s然后输入词就可以快速搜索,这点就是很舒服的地方,下面两个图 flash easy-motion 另外我也没有在vim插件的文档中找到如何更改easymotion的快捷键的地方,如果可以改的话也可以进行配置(我的intellij idea就是通过这个更改实现类flash模式) 而vscode中的neovim插件可以使用neovim的原生插件,这一点就非常舒服了,这个插件的基本原理大概就是:使用vscode去连接一个neovim实例,然后在command和normal模式下,将用户输入的命令直接传给neovim 配置安装就不多说了,有手就行 有一些需要注意的地方是: 需要指定neovim的安装位置 如果需要个性化配置,可以制定一个init.lua/init.vim文件 具体配置选项可以看这里 我的配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172-- _ _-- _ __ | | _ _ __ _ (_) _ __-- | '_ \\ | | | | | | / _` | | | | '_ \\-- | |_) | | | | |_| | | (_| | | | | | | |-- | .__/ |_| \\__,_| \\__, | |_| |_| |_|-- |_| |___/--local lazypath = vim.fn.stdpath(&quot;data&quot;) .. &quot;/lazy/lazy.nvim&quot;if not vim.loop.fs_stat(lazypath) then -- bootstrap lazy.nvim -- stylua: ignore vim.fn.system({ &quot;git&quot;, &quot;clone&quot;, &quot;--filter=blob:none&quot;, &quot;https://github.com/folke/lazy.nvim.git&quot;, &quot;--branch=stable&quot;, lazypath })endvim.opt.rtp:prepend(vim.env.LAZY or lazypath)require('lazy').setup({ { &quot;kylechui/nvim-surround&quot;, version = &quot;*&quot;, -- Use for stability; omit to use `main` branch for the latest features event = &quot;VeryLazy&quot;, config = function() require(&quot;nvim-surround&quot;).setup({ -- Configuration here, or leave empty to use defaults }) end }, { &quot;folke/flash.nvim&quot;, event = &quot;VeryLazy&quot;, ---@type Flash.Config opts = {}, -- stylua: ignore keys = { { &quot;s&quot;, mode = { &quot;n&quot;, &quot;o&quot;, &quot;x&quot; }, function() require(&quot;flash&quot;).jump() end, desc = &quot;Flash&quot; }, { &quot;S&quot;, mode = { &quot;n&quot;, &quot;o&quot;, &quot;x&quot; }, function() require(&quot;flash&quot;).treesitter() end, desc = &quot;Flash Treesitter&quot; }, -- { &quot;r&quot;, mode = &quot;o&quot;, function() require(&quot;flash&quot;).remote() end, desc = &quot;Remote Flash&quot; }, { &quot;R&quot;, mode = { &quot;o&quot;, &quot;x&quot; }, function() require(&quot;flash&quot;).treesitter_search() end, desc = &quot;Treesitter Search&quot; }, { &quot;&lt;c-s&gt;&quot;, mode = { &quot;c&quot; }, function() require(&quot;flash&quot;).toggle() end, desc = &quot;Toggle Flash Search&quot; }, }, }})-- _-- __ __ ___ ___ ___ __| | ___-- \\ \\ / / / __| / __| / _ \\ / _` | / _ \\-- \\ V / \\__ \\ | (__ | (_) | | (_| | | __/-- \\_/ |___/ \\___| \\___/ \\__,_| \\___|---- __ _-- ___ ___ _ __ / _| (_) __ _-- / __| / _ \\ | '_ \\ | |_ | | / _` |-- | (__ | (_) | | | | | | _| | | | (_| |-- \\___| \\___/ |_| |_| |_| |_| \\__, |-- |___/--local map = vim.keymap.setlocal expr_options = { expr = true, silent = true }-- 这里很重要,防止光标到折叠为止,折叠自动展开map(&quot;n&quot;,&quot;k&quot;,&quot;gk&quot;,{remap = true})map(&quot;n&quot;,&quot;j&quot;,&quot;gj&quot;,{remap = true})map('n','zc',&quot;&lt;cmd&gt;call VSCodeCall('editor.fold')&lt;cr&gt;&quot;)map('n','zo',&quot;&lt;cmd&gt;call VSCodeCall('editor.unfold')&lt;cr&gt;&quot;)map('n','zR',&quot;&lt;cmd&gt;call VSCodeCall('editor.unfoldAll')&lt;cr&gt;&quot;)map('n','zM',&quot;&lt;cmd&gt;call VSCodeCall('editor.foldAll')&lt;cr&gt;&quot;)map('n','&lt;leader&gt;e',&quot;&lt;cmd&gt;call VSCodeCall('workbench.action.quickOpenNavigateNextInFilePicker')&lt;cr&gt;&quot;,{remap=true}) 注意 123-- 这里很重要,防止光标到折叠为止,折叠自动展开map(&quot;n&quot;,&quot;k&quot;,&quot;gk&quot;,{remap = true})map(&quot;n&quot;,&quot;j&quot;,&quot;gj&quot;,{remap = true}) 这两句配置很是很重要的,如果不配置,在neovim模式下,光标移动到折叠为止,折叠会自动展开","link":"/2023/09/23/vscode-neovim-plugin/"}],"tags":[{"name":"gradle","slug":"gradle","link":"/tags/gradle/"},{"name":"spring-boot","slug":"spring-boot","link":"/tags/spring-boot/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"ganesha","slug":"ganesha","link":"/tags/ganesha/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"neovim","slug":"neovim","link":"/tags/neovim/"},{"name":"idea","slug":"idea","link":"/tags/idea/"},{"name":"encode","slug":"encode","link":"/tags/encode/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"macos","slug":"macos","link":"/tags/macos/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"terminal","slug":"terminal","link":"/tags/terminal/"},{"name":"快捷键","slug":"快捷键","link":"/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"asdf","slug":"asdf","link":"/tags/asdf/"},{"name":"asdf manage","slug":"asdf-manage","link":"/tags/asdf-manage/"}],"categories":[{"name":"gradle","slug":"gradle","link":"/categories/gradle/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"ganesha","slug":"ganesha","link":"/categories/ganesha/"},{"name":"neovim奇技淫巧","slug":"neovim奇技淫巧","link":"/categories/neovim%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"},{"name":"some litttle tricks","slug":"some-litttle-tricks","link":"/categories/some-litttle-tricks/"},{"name":"万物皆可vim","slug":"万物皆可vim","link":"/categories/%E4%B8%87%E7%89%A9%E7%9A%86%E5%8F%AFvim/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"shell","slug":"shell","link":"/categories/shell/"},{"name":"键指如飞","slug":"键指如飞","link":"/categories/%E9%94%AE%E6%8C%87%E5%A6%82%E9%A3%9E/"},{"name":"效率工具","slug":"效率工具","link":"/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"}],"pages":[]}