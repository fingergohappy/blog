{"title":"java byte array 转String在转回byte array不相等","uid":"21c88c674175238dff17f5ecc1cb05a5","slug":"java-byte-convert-string-not-equal","date":"2023-09-21T20:39:21.000Z","updated":"2023-11-07T19:45:10.327Z","comments":true,"path":"api/articles/java-byte-convert-string-not-equal.json","keywords":null,"cover":"https://source.unsplash.com/AtccjBkdl-I/1200x628","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>最近在搞微软的<code>NBFS</code>协议,这个协议实际上也是基于<code>WebService</code>,只不过对<code>xml</code>进行了压缩,按照他自己的编码规则进行压缩<br>网上搜罗一圈后发现有个大佬写好的<code>burp</code>的<code>NBFS</code>插件<a href=\"https://github.com/GDSSecurity/WCF-Binary-SOAP-Plug-In\">WCF-Binary-SOAP-Plug-In</a><br>这个插件会将传入的经过<code>base64</code>编码的<code>xml</code>转换成<code>NBFS</code>协议的<code>base64</code>编码的字符串</p>\n<p>测试那边要使用<code>jmeter</code>对这个<code>NBFS</code>接口性能测试<br>基本思路:</p>\n<ul>\n<li>新建<code>http request</code>输入原始的<code>xml</code></li>\n<li>搞一个<code>PreProcessor</code>,调用大佬写的<code>NBFS.exe</code>获取压缩后的<code>XML</code>base64编码的字符串</li>\n</ul>\n<p>PreProcessor 代码如下</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取请求体数据</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> requestBody = sampler.getArguments().getArgument(<span class=\"number\">0</span>).getValue();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 检查请求体是否存在</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (requestBody != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;获取到请求体:&#123;&#125;&quot;</span>,requestBody)</span><br><span class=\"line\">    <span class=\"comment\">// 进行加密操作，这里使用Base64编码作为示例</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> reqBase64Str = Base64.encodeBase64String(requestBody.getBytes());</span><br><span class=\"line\">    <span class=\"keyword\">def</span> process = Runtime.getRuntime().exec(<span class=\"string\">&quot;./NBFS.exe&quot;</span>,<span class=\"string\">&quot;encode&quot;</span>,reqBase64Str)</span><br><span class=\"line\">    process.waitFor()</span><br><span class=\"line\">    <span class=\"keyword\">def</span> nbfsEncodeBase64Str = process.inputStream.text</span><br><span class=\"line\">    <span class=\"keyword\">def</span> result = Base64.decodeBase64(nbfsEncodeBase64Str)</span><br><span class=\"line\">    <span class=\"comment\">// 将加密后的数据设置回请求体</span></span><br><span class=\"line\">    sampler.getArguments().getArgument(<span class=\"number\">0</span>).setValue(<span class=\"keyword\">new</span> String(result));</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    log.warn(<span class=\"string\">&quot;请求体不存在&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这时候就会发现一个神奇的东西,接口会返回<code>400</code>错误</p>\n<h1 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h1><p>先说明下<code>NBFS</code>编码的原理,为了压缩<code>xml</code>,<code>NBFS</code>会预先定义一些字典,比如:<code>0x90</code>代表<code>Reason</code>这个字符,<br>也就是说,经过<code>NBFS.exe</code>返回的<code>Base64</code>字符串经过<code>Base64.decodeBase64(nbfsEncodeBase64Str)</code>这个方法返回的byte数组中可能出现<code>0x80,0xAA</code>等字节</p>\n<p>众所周知,java默认的字符串编码是<code>UTF-8</code></p>\n<p>另一个常识是:java字符串是由<code>Char[]</code>表示的,而<code>Char</code>是由<code>unicode</code>表示</p>\n<p>ok,有了上面的已知条件,返回400的问题,就是解释为什么下面代码输出是<code>false</code>就行了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">byte</span>[] byteArray = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">0x01</span>, (<span class=\"type\">byte</span>)<span class=\"number\">0x81</span>, (<span class=\"type\">byte</span>)<span class=\"number\">0xAA</span>, <span class=\"number\">0x44</span>, <span class=\"number\">0x45</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(byteArray);</span><br><span class=\"line\"><span class=\"type\">byte</span> [] revertByteArray = str.getBytes();</span><br><span class=\"line\">System.out.println(Arrays.equals(byteArray,revertByteArray));</span><br></pre></td></tr></table></figure>\n\n<p>其实断点调试下,会发现其实<code>revertByteArray</code>这个数组其实是:<code>[1, -17, -65, -67, -17, -65, -67, 68, 69]</code>而原数组是:<code>[1, -128, -86, 68, 69]</code><br>区别就是多出了6个byte,其中<code>0x81</code>,<code>0xAA</code>对应变成<code>[-17,-65,-67]</code>,对应10进制的65533,对应的unicde就是:<code>\\uFFFD</code></p>\n<p>接下来就分析一下为什么<code>0x81</code>为什么会变成<code>[-17,-65,-67]</code>这玩意就行了</p>\n<h1 id=\"debug大法\"><a href=\"#debug大法\" class=\"headerlink\" title=\"debug大法\"></a>debug大法</h1><p>对<code>new String(byteArr)</code>这段代码开始debug,<br>就会发现最终会进入一个超长的方法:</p>\n<p><code>sun.nio.cs.UTF_8.Decoder#decode</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// da 就是字符串找保存的char[]</span></span><br><span class=\"line\"><span class=\"comment\">// sa 就是String构造函数传进来的byte 数组</span></span><br><span class=\"line\"><span class=\"comment\">// 就是这个方法将byte [] -&gt; char []</span></span><br><span class=\"line\"><span class=\"comment\">// sp 是0,应该是偏移量,      String str = new String(byteArray,1,1,&quot;UTF-8&quot;);这么创建字符串才会有,这个不重要,</span></span><br><span class=\"line\"><span class=\"comment\">// len就是byte数组的长度</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">decode</span><span class=\"params\">(<span class=\"type\">byte</span>[] sa, <span class=\"type\">int</span> sp, <span class=\"type\">int</span> len, <span class=\"type\">char</span>[] da)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">sl</span> <span class=\"operator\">=</span> sp + len;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">dp</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">dlASCII</span> <span class=\"operator\">=</span> Math.min(len, da.length);</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">bb</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;  <span class=\"comment\">// only necessary if malformed</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// ASCII only optimized loop</span></span><br><span class=\"line\">            <span class=\"comment\">//性能优化,&gt;= 0的意思就是byte没有溢出,也就是:0~128,对应就是0x00 到 0x00 0x80</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (dp &lt; dlASCII &amp;&amp; sa[sp] &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                da[dp++] = (<span class=\"type\">char</span>) sa[sp++];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//下面就是范围判断,判断byte是否在utf8的编码范围内</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (sp &lt; sl) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">b1</span> <span class=\"operator\">=</span> sa[sp++];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (b1 &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 1 byte, 7 bits: 0xxxxxxx</span></span><br><span class=\"line\">                    da[dp++] = (<span class=\"type\">char</span>) b1;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((b1 &gt;&gt; <span class=\"number\">5</span>) == -<span class=\"number\">2</span> &amp;&amp; (b1 &amp; <span class=\"number\">0x1e</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 2 bytes, 11 bits: 110xxxxx 10xxxxxx</span></span><br><span class=\"line\">                    .</span><br><span class=\"line\">                    .</span><br><span class=\"line\">                    .</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((b1 &gt;&gt; <span class=\"number\">4</span>) == -<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 3 bytes, 16 bits: 1110xxxx 10xxxxxx 10xxxxxx</span></span><br><span class=\"line\">                    .</span><br><span class=\"line\">                    .</span><br><span class=\"line\">                    .</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((b1 &gt;&gt; <span class=\"number\">3</span>) == -<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 4 bytes, 21 bits: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span></span><br><span class=\"line\">                    .</span><br><span class=\"line\">                    .</span><br><span class=\"line\">                    .</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (malformedInputAction() != CodingErrorAction.REPLACE)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">                    da[dp++] = replacement().charAt(<span class=\"number\">0</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dp;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>上面代码翻译成人话就是:<br>循环byte数组里面的每一个byte</p>\n<ol>\n<li>如果&gt;&#x3D;0,就是ASCII</li>\n<li>如果不是,判断是否符合条件:<ol>\n<li>1 byte, 7 bits: 0xxxxxxx</li>\n<li>2 bytes, 11 bits: 110xxxxx 10xxxxxx</li>\n<li>3 bytes, 16 bits: 1110xxxx 10xxxxxx 10xxxxxx</li>\n<li>4 bytes, 21 bits: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</li>\n</ol>\n</li>\n<li>如果都不符合,就返回<code>replacement()</code>第0个char(打断点看,这个字符其实就是main类启动时创建的,其实这就是’65533’也就是<code>\\uFFFD</code>)</li>\n</ol>\n<p>至此,真相大白</p>\n<p><code>0x80</code>-&gt;<code>0b10000000</code><br><code>0x88</code>-&gt;<code>0b10010000</code></p>\n<p>都不在上面的范围,所以他们最终的<code>char</code>最终都会变成<code>65533</code>(<code>\\uFFFD</code>)</p>\n<p>其实上面的规则就是<code>UTF-8</code>规则,参考<a href=\"https://zh.wikipedia.org/wiki/UTF-8\">维基百科</a>:</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>  在ASCII码的范围，用一个字节表示，超出ASCII码的范围就用字节表示，这就形成了我们上面看到的UTF-8的表示方法，这样的好处是当UNICODE文件中只有ASCII码时，存储的文件都为一个字节，所以就是普通的ASCII文件无异，读取的时候也是如此，所以能与以前的ASCII文件兼容。<br>  大于ASCII码的，就会由上面的第一字节的前几位表示该unicode字符的长度，比如110xxxxx前三位的二进制表示告诉我们这是个2BYTE的UNICODE字符；1110xxxx是个三位的UNICODE字符，依此类推；xxx的位置由字符编码数的二进制表示的位填入。越靠右的x具有越少的特殊意义。只用最短的那个足够表达一个字符编码数的多字节串。注意在多字节串中，第一个字节的开头”1”的数目就是整个串中字节的数目。</p></blockquote>\n<h1 id=\"太长不看\"><a href=\"#太长不看\" class=\"headerlink\" title=\"太长不看\"></a>太长不看</h1><p>一句话总结:因为类似<code>0x80</code>,<code>0x88</code>等字节不在<code>utf-8</code>编码范围内,所以会返回一个默认字符,<code>\\uFFFD</code>(65533),这个字符占3个字节,所以就造成的两个byte数组不相等</p>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><p>解决方法很简单:<br>找一个编码覆盖<code>0x00</code> 到 <code>0xff</code>,并且只用一个字节编码的编码格式就行,<br>没错,就是你-<code>ISO-8859-1</code>!</p>\n<p>所以下面代码输出就是<code>true</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">byte</span>[] byteArray = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">0x01</span>, (<span class=\"type\">byte</span>)<span class=\"number\">0x81</span>, (<span class=\"type\">byte</span>)<span class=\"number\">0xAA</span>, <span class=\"number\">0x44</span>, <span class=\"number\">0x45</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(byteArray,<span class=\"string\">&quot;ISO-8859-1&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">byte</span> [] revertByteArray = str.getBytes(<span class=\"string\">&quot;ISO-8859-1&quot;</span>);</span><br><span class=\"line\">System.out.println(Arrays.equals(byteArray,revertByteArray));</span><br></pre></td></tr></table></figure>\n\n","feature":true,"text":"java byte array 转String在转回byte array不相等...","permalink":"/post/java-byte-convert-string-not-equal","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"java","slug":"java","count":1,"path":"api/categories/java.json"}],"tags":[{"name":"java","slug":"java","count":1,"path":"api/tags/java.json"},{"name":"encode","slug":"encode","count":1,"path":"api/tags/encode.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90\"><span class=\"toc-text\">问题分析</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#debug%E5%A4%A7%E6%B3%95\"><span class=\"toc-text\">debug大法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A4%AA%E9%95%BF%E4%B8%8D%E7%9C%8B\"><span class=\"toc-text\">太长不看</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">解决方法</span></a></li></ol>","author":{"name":"finger","slug":"blog-author","avatar":"/assets/images/logo.jpg","link":"/","description":"do something funny","socials":{"github":"https://github.com/fingergohappy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"macos下,实现vim切换模式自动切换输入法","uid":"a80e863ad04e203843f50e139a5edeb2","slug":"macos-vim-auto-change-input-method","date":"2023-09-20T10:37:19.000Z","updated":"2023-11-07T19:45:10.327Z","comments":true,"path":"api/articles/macos-vim-auto-change-input-method.json","keywords":null,"cover":"https://source.unsplash.com/m_HRfLhgABo/1200x628","text":"macos结合使用,vim切换模式实现自动切换输入法...","permalink":"/post/macos-vim-auto-change-input-method","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"some litttle tricks","slug":"some-litttle-tricks","count":2,"path":"api/categories/some-litttle-tricks.json"}],"tags":[{"name":"vim","slug":"vim","count":3,"path":"api/tags/vim.json"},{"name":"macos","slug":"macos","count":1,"path":"api/tags/macos.json"}],"author":{"name":"finger","slug":"blog-author","avatar":"/assets/images/logo.jpg","link":"/","description":"do something funny","socials":{"github":"https://github.com/fingergohappy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}