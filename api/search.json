[{"id":"56b23b84b250019b3083e955ae6b9980","title":"gradle将spring-boot和vue打入一个jar包","content":"之前用maven搞过将spring-boot和vue打成一个jar包,现在的项目,我使用了gralde,又是同样的需求,使用gradle的composite似乎更优雅一些.\n项目结构12345678910.├── build.gradle.kts├── settings.gradle.kts├── app #spring-boot 目录│   ├── build.gradle.kts│   ├── settings.gradle.kts├── web #vue目录│   ├── build.gradle.kts│   ├── settings.gradle.kts\n结构说明app和web分别为spring-boot和vue项目,就正常写就行,唯一不同的就是,vue项目里面添加一个gradle配置文件,\n配置文件说明需要改动的地方就只有web和最外面的项目的gradle的配置文件需要改动\nweb其中web的build.gradle.kts内容如下:\n123456789101112plugins&#123;        base&#125;tasks&#123;        register&lt;Exec&gt;(&quot;build-dev&quot;)&#123;            workingDir(&quot;./&quot;)            commandLine(&quot;pnpm&quot;,&quot;run&quot;,&quot;build:dev&quot;)        &#125;&#125;\n就是添加了一个打包任务\n根目录根目录的gradle配置文件需要调整的地方比较多\nsetting.gradle.kts:\n1234567rootProject.name = &quot;example&quot;// 这里很重要,使用includeBuild完成组合构建includeBuild(&quot;./app&quot;)includeBuild(&quot;./web&quot;)\n\nbuild.gradle.kts:\n123456789101112131415161718192021222324plugins &#123;        base&#125;tasks&#123;    register(&quot;build-all&quot;)&#123;        dependsOn(gradle.includedBuild(&quot;app&quot;).task(&quot;:classes&quot;))        dependsOn(gradle.includedBuild(&quot;web&quot;).task(&quot;:build-dev&quot;))    &#125;    register&lt;Copy&gt;(&quot;copy-static&quot;)&#123;        dependsOn(&quot;build-all&quot;)        // gradle没有提供通过includeBuild直接获取build目录的api,只能这样写死        val webDistPath = gradle.includedBuild(&quot;web&quot;).projectDir.getPath() + &quot;/dist-dev&quot;        val appClassesPath = gradle.includedBuild(&quot;app&quot;).projectDir.getPath() + &quot;/build/resources/main/static&quot;        from(webDistPath)&#123;                include(&quot;*&quot;)        &#125;        into(appClassesPath)    &#125;    register(&quot;build-jar&quot;)&#123;        dependsOn(&quot;copy-static&quot;)        dependsOn(gradle.includedBuild(&quot;app&quot;).task(&quot;:jar&quot;))    &#125;&#125;\n\n这样执行gradle :build-jar,就会生成一个带有vue打包后的dist目录的jar包\n","slug":"gradle-spring-boot-vue-one-jar","date":"2023-11-11T15:23:43.000Z","categories_index":"gradle","tags_index":"gradle,spring-boot","author_index":"finger"},{"id":"278663bc5f0ce8aa9f1bcfa6468a4791","title":"neovim配置formatters","content":"最近再搞vue3,使用了element plus admin这个模版库,没想到一直报错后来经过排查发现是这个模板库使用了prettier这位lint的配置项,简单来说就是如果不符合他的格式就会报错,而我的neovim是使用的volar这个lsp作为格式化话的后端,想要保存自动安装prettier的格式格式化,需要额外加一些配置\n本来是想打算用null-ls,因为更符合哲学的,其实就是将一些formatter作为neovim原生的lspinject进去不过这个项目目前停更了,而且我也只是想保存的时候格式化就行了,所以就选择了另一个插件formatter.nvim\n安装安装prettier在mason中找到prettier安装就行不过这个地方比较有意思,mason其实是安装了prettier的,按时我在终端中缺无法使用,后来发现mason安装的工具其实是在~/.local/share/nvim/mason/bin/里面,然后在放到neovim内置的环境变量中是,在neovim的命令模式执行:!env就可以看到\n安装formatter.nvim123456789101112131415161718192021&#123;        &quot;mhartington/formatter.nvim&quot;,        name = &quot;formatter&quot;,            event = &quot;BufEnter&quot;,            enabled = true,            # 这个配置一定要写到config选项中,不然会报错            config = function(LazyPlugin,opts)            local opts = &#123;                logging = true,                log_level = vim.log.levels.WARN,                filetype = &#123;                    vue = &#123;                        require(&quot;formatter.filetypes.vue&quot;).prettier(),                        _                        &#125;                &#125;            &#125;            require(&quot;formatter&quot;).setup(opts)        end    &#125;\n\n这里需要注意的点是\n\nformatter并没用给默认的格式化配置,所以没中文件都要配置\n配置想要写到lazyvim的config选项中,不然会提示找不到formatter.filetypes.vue\n\n保存自动格式化12vim.api.nvim_create_autocmd(&#123;&quot;BufWritePost&quot;&#125;,&#123;pattern = &#123;&quot;*&quot;&#125;,command = &quot;FormatWrite&quot;&#125;)\n\n原理formatter.nvim相当于一个接口,然后自己配置格式化命令,当执行格式化命令时,会调用你配置的格式化命令,如果不配置就是使用默认的,想上面的vue执行格式化的时候其实就是在执行默认的格式化,约等于下面的伪代码:\n1prettier --stdin-filepath %\n","slug":"neovim-config-formatter","date":"2023-11-01T16:05:14.000Z","categories_index":"neovim奇技淫巧","tags_index":"neovim","author_index":"finger"},{"id":"b44d691eb810037cdb9efa730e0764ea","title":"管道操作符和xargs的区别","content":"之前一直没有理解shell中管道操作符和xargs的区别,为什么有一些命令要用可以直接用管道操作符链接,为什么一些需要加个xargs,最近翻了一些文档之后,终于理解\n官方定义最好的解释永远来自于官方文档,正所谓真传一句话,假传万卷书.\n管道操作符A pipeline is a sequence of one or more commands separated by one of the control operators ‘|’ or ‘|&amp;’.The output of each command in the pipeline is connected via a pipe to the input of the next command. That is, each command reads the previous command’s output. This connection is performed before any redirections specified by command1.\n简单来说就是,管道操作符连接一系列命令,前面的标准输出作为后面的标准输入\nxargsThe xargs utility reads space, tab, newline and end-of-file delimited strings from the standard input and executes utility with the strings     as arguments.Any arguments specified on the command line are given to utility upon each invocation, followed by some number of the arguments read fromthe standard input of xargs.  This is repeated until standard input is exhausted.\nSpaces, tabs and newlines may be embedded in arguments using single ( &#39; &#39;&#39;) or double (“‘’) quotes or backslashes (&#96;&#96;&#39;‘).  Singlequotes escape all non-single quote characters, excluding newlines, up to the matching single quote.  Double quotes escape all non-doublequote characters, excluding newlines, up to the matching double quote.  Any single character, including newlines, may be escaped by abackslash.\n简单来说,就是xargs是从标准输入读取内容,作为xrags命令后面跟的命令的参数\n举个例子管道操作符1echo &quot;hello \\n world&quot; | grep hello\n\necho &quot;hello world&quot; 会将hello world字符串输出到标准输出,然后通过管道操作符作为 grep hello这条命令的标准输入\n上面的命令相当于下面的命令\n12345grep hello      # 执行完按回车hello       # 输入hello worldhello      # 打印helloworld   # 输入world 什么也不打印\n\nxargs12xargs ls #按回车/usr     #按ctrl-d 会打印/usr目录下的所有文件\n\nctrl-d相当于向shell输入了一个eof,表示输入完成\n组合这两个命令一般是组合使用\n比如:\n1cat a.txt | xargs mkdir -p \n\n这条命令的含义是,将a.ext文件中的内容作为文件夹名,新建一个文件夹其中,cat a.txt命令是将a.txt中的内容输出到标准输出,然后通过管道操作符作为xargs mkdir -p这个命令的标准输入,xargs将前面传过来的标准输入作为mkdir -p 这条命令的参数\n标准输入&#x2F;标准输出&#x2F;参数在linux中,默认情况下\n标准输入是指键盘标准输出是指屏幕参数就是命令后面跟着的内容\n举个例子12345$ cat hello-world.txt #  hello-world.txt 是参数$ cat   #执行cat命令后回车$ hello  #输入hello   这里的hello就是标准输入$ hello  # 命令行打印hello  这里打印的hello就是找女友输入\n\n\n\n\n","slug":"shell-pipeline-and-xargs","date":"2023-10-31T17:38:16.000Z","categories_index":"shell","tags_index":"shell","author_index":"finger"},{"id":"10511efcdf050e7b6a632b67005878d9","title":"idea怎么在project 选项卡中隐藏特定的文件和文件夹","content":"在日常使用idea项目开发中,有些文件或者文件夹不想在project选项卡中显示,想要隐藏掉,隐藏方法:\nFile -&gt; Settings -&gt; Editor -&gt; File Types -&gt; Ignore Files And folders\n","slug":"idea-how-to-hide-folder-in-project","date":"2023-10-13T15:01:29.000Z","categories_index":"some litttle tricks","tags_index":"idea","author_index":"finger"},{"id":"20b1dd25546ad76a413c67b885fd05e2","title":"手把手教你开发一个neovim插件","content":"开篇废话使用neovim久了,使用了众多插件,不自己开发一个插件,怎么好标榜自己是一个vimer?今天老夫就手把手教大家开发一个自己的neovim插件\n项目结构与插件路径插件路径这里差不多也是废话,理论上来说,vim的插件可以在任何位置,插件的方式也可以是各种形式,不过为了这里面还是有一些潜规则的.首先就是插件的路径了,一般来说,neovim会默认加载一些路径,可以在neovim中执行echo &amp;rtp(rtp:runtim time path)来查看默认的加载路径有哪些,不过由于我们是自己开发的插件,就暂时不要放在这些路径里面了,避免启动时报错,假设我现在放在了~/temp/neovim/lua/lowb这个目录下进行开发lowb插件,然后在启动neovim的时候使用nvim --cmd &quot;set rtp+=~/temp/neovim&quot;启动就可以加载lowb插件了,插件名就是lua路径下的文件夹名,如果你的插件比较简单,可以不用新建一个文件夹,直接搞一个lowb.lua就可以加载了,不过按照约定一般是有一个文件夹的,方便发布,供其他人使用\n这里需要注意,一定放在lua的子目录下,否则neovim是不会进行加载这个插件的,参考\n项目结构init.luaneovim会自动加载目录下的init.lua作为neovim的默认加载文件\n开始开发加载确定了插件路径和项目结构,就可以开发lowb插件了,在~/temp/neovim/lua/lowb,先新建一个init.lua文件,文件内容如下:\n12print(&quot;Hello lowb&quot;)\n\n然后使用nvim -c &quot;set rtp+=~/temp/neovim&quot;启动neovim \n进入neovim的命令模式执行:lua require(&#39;lowb&#39;)可以看到会打印Hello lowbOK,现在插件成功加载了\n导出函数插件肯定不能简单的加载,还要导出一些函数供用户使用,更新init.lua\n123456local M = &#123;&#125;function M.say_lowb()    print(&quot;hello lowb&quot;)endreturn M\n\n\n保存插件,重新使用命令nvim -c &quot;set rtp+=~/temp/neovim&quot;启动neovim进入neovim的命令模式执行:lua require(&#39;lowb&#39;).say_lowb()\n现在lowb插件基本完成,还有一项功能就是给用户设置的能力\nsetup函数neovim插件一般是通过向外暴露一个setup函数来给用户设定,这倒不是强制规定,只是一个默认约定,像一些插件管理工具,比如lazy.vim一般就是默认使用setup来进行初始化插件,\n现在再改一下init.lua文件\n1234567891011121314151617181920local default_config = &#123;    name = &quot;狗蛋&quot;&#125;local M = &#123;    config = default_config&#125;function M.say_lowb()    print(&quot;hello lowb &quot;..M.config.name)endfunction M.setup(config)    M.config = config    vim.print(M)endreturn M\n\n保存退出,重新使用命令:nvim -c &quot;set rtp+=~/temp/neovim&quot; 启动neovim,\n进入命令模式执行以下命令\n123lua require(&#x27;lowb&#x27;).setup(&#123;name=finger&#125;)lua require(&#x27;lowb&#x27;).say_lowb()\n就会看到打印的信息从”狗蛋”更新为”finger”\n现在一个简单的neovim插件就开发完成了,至于能做什么\n想象力越大,能力越大\n","slug":"how-to-develope-a-neovim-plugin","date":"2023-10-12T17:10:19.000Z","categories_index":"neovim奇技淫巧","tags_index":"neovim","author_index":"finger"},{"id":"001dfc01a72db15c12cec35ea2336846","title":"使用asdf管理你的sdk","content":"对于我这种使用多种语言开发,并且可能在给个版本之前来回切换的人来说,一直渴望一个好的sdk管理工具举个具体的例子:有两个项目,一个项目使用jdk-8另一个项目使用jdk-17,在ide里面还好说,毕竟可选择,但是当你在命令行里面操作时,来回切换jdk有多难受就不必我多说了吧而且如果要用两个jdk,这两个就要使用HomeBrew安装两个jdk,而且安装的路径还不一样\n除此之外,还有前端的node版本,不同的项目使用的NodeJs版本不同,换来换区也是麻烦的不行\n这个时候就体现了asdf这个工具的方便之处,\n如果使用来asdf,那么安装和切换jdk的版本就会如此美妙\n现在假设在使用asdf的情况下,如果有两个项目a 和 b,分别使用jdk-8和jdk-17,那么管理的流程就是如下的\n\n安装对应的jdk:asdf install java openjdk-8, asdf install java openjdk-17\n分别进入a和b两个目录,执行asdf local java openjdk-8,asdf local java openjdk-17\n\n这个时候,当你在命令行进入对应的项目,你执行java -version就会对应不同的jdk版本\n而且安装的jdk统一的都在~/.asdf.plugins/java目录下,丝毫不会污染你其他的目录,干净又卫生了属于是\n下面简单说下安装以及使用,基本上是官方文档内容\n安装我是使用HomeBrew安装\n123brew install asdfecho -e &quot;\\n. $(brew --prefix asdf)/libexec/asdf.sh&quot; &gt;&gt; $&#123;ZDOTDIR:-~&#125;/.zshrc\n\n\n使用(以java为例)plugin在asdf的语义中,plugin就是帮你管理对应语言sdk的模块,比如你需要下载是管理java的版本,你就需要下载对应的java plugin\n搜索plugin1asdf plugin list all | grep java\n\n\n安装plugin1asdf plugin add java\n\n\n安装sdk12345678910# 搜索jdkasdf list all java | grep jdk # 安装jdk    # 安装指定版本asdf install java openjdk-17.0    # 安装指定版本的最新版本asdf install java openjdk-17:latest    # 安装最新稳定版asdf install java latest\n\n设置12345# 设置命令行使用的版本asdf global java openjdk-17# 设置当前路径使用的jdk版本,会在当前目录下生成一个.tool-versions文件asdf local java openjdk-17\n\n\n其他常用命令12345678910111213141516# 查看当前各个sdk的版本asdf current# 查看当前java使用的sdk版本asdf current java# 查看安装那些pluginasdf plugin list# 查看当前使用的java 命令的路径asdf  which java# 查看当前使用的java sdk的路径asdf where java# 移除对应的sdkasdf uninstall java openjdk-17# 移除对应的pluginasdf plugin remove java# 更新(所有)pluginasdf plugin update [--all]\n\n参考资料asdf官方文档\n","slug":"use-asdf-manage-sdk","date":"2023-09-26T12:18:16.000Z","categories_index":"效率工具","tags_index":"asdf,asdf manage","author_index":"finger"},{"id":"57888b1aa0de4d6b4f5f40549dd40c1c","title":"终端下常用快捷键汇总","content":"说明其实大部分都是emacs的快捷键,终端也可以切换为vim模式,快捷键就会有变化\nC : CtrlA : ALT\n光标移动\n\n\n快捷键\n效果\n\n\n\nC-a\n移动到行首\n\n\nC-e\n移动到行尾\n\n\nC-f\n向后移动一个字符\n\n\nC-b\n向前移动一个字符\n\n\nC-xx\n在行首和当前光标位置之间互相切换\n\n\nA-f &#x2F; ESC-f\n向后移动一个单词\n\n\nA-b &#x2F; ESC-b\n向前移动一个单词\n\n\n控制和处理流程\n\n\n快捷键\n效果\n\n\n\nC-l\n清除命令行历史输出\n\n\nC-z\n挂起当前程序\n\n\nC-q\n回复挂起的程序\n\n\nC-i\n等于tab\n\n\nC-j\n等于enter\n\n\n编辑\n\n\n快捷键\n效果\n\n\n\nC-d\n删除后一个字符\n\n\nC-h\n删除光标钱一个字符\n\n\nC-k\n从光标删除到行尾\n\n\nC-u\n从光标删除到行首\n\n\nC-w\n删除光标前的一个单词\n\n\nA-t &#x2F; Esc-t\n替换当前光标的单词和前一个单词的位置\n\n\n历史相关的\n\n\n快捷键\n效果\n\n\n\nC-r\n搜索历史\n\n\nC-p\n上一条命令\n\n\nC-n\n下一条命令\n\n\n","slug":"terminal-shortcuts","date":"2023-09-24T15:44:05.000Z","categories_index":"键指如飞","tags_index":"terminal,linux,快捷键","author_index":"finger"},{"id":"90c7996616891eec86d1200649d04cd6","title":"vscode更好用的vim插件","content":"前言对我来说,使用vim后有两个后遗症,一是想把vim配置的全知全能,二是在任何软件中都想启用vim模式,现在前者的症状已经有所减轻,后者愈发严重\n更好用的vim插件之前在 vscode中使用的 vim插件一直是vim,但是这个插件有一个让我非常苦恼的问题,就是这个插件没有neovim中的flash插件,它默认的快速移动插件是easymotion,个人觉得,easymotion这个插件的已送快捷键方式实在是太不方便,举个简单的例子:他的prefix是要按两下leader按键,而flash插件就十分的方便,按下s然后输入词就可以快速搜索,这点就是很舒服的地方,下面两个图\nflash\neasy-motion\n\n另外我也没有在vim插件的文档中找到如何更改easymotion的快捷键的地方,如果可以改的话也可以进行配置(我的intellij idea就是通过这个更改实现类flash模式)\n而vscode中的neovim插件可以使用neovim的原生插件,这一点就非常舒服了,这个插件的基本原理大概就是:使用vscode去连接一个neovim实例,然后在command和normal模式下,将用户输入的命令直接传给neovim\n配置安装就不多说了,有手就行\n有一些需要注意的地方是:\n\n需要指定neovim的安装位置\n如果需要个性化配置,可以制定一个init.lua&#x2F;init.vim文件\n\n具体配置选项可以看这里\n我的配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071--                              _                   _--                      _ __   | |  _   _    __ _  (_)  _ __--                     | &#x27;_ \\  | | | | | |  / _` | | | | &#x27;_ \\--                     | |_) | | | | |_| | | (_| | | | | | | |--                     | .__/  |_|  \\__,_|  \\__, | |_| |_| |_|--                     |_|                  |___/--local lazypath = vim.fn.stdpath(&quot;data&quot;) .. &quot;/lazy/lazy.nvim&quot;if not vim.loop.fs_stat(lazypath) then  -- bootstrap lazy.nvim  -- stylua: ignore  vim.fn.system(&#123; &quot;git&quot;, &quot;clone&quot;, &quot;--filter=blob:none&quot;, &quot;https://github.com/folke/lazy.nvim.git&quot;, &quot;--branch=stable&quot;, lazypath &#125;)endvim.opt.rtp:prepend(vim.env.LAZY or lazypath)require(&#x27;lazy&#x27;).setup(&#123;    &#123;        &quot;kylechui/nvim-surround&quot;,        version = &quot;*&quot;, -- Use for stability; omit to use `main` branch for the latest features        event = &quot;VeryLazy&quot;,        config = function()            require(&quot;nvim-surround&quot;).setup(&#123;                -- Configuration here, or leave empty to use defaults            &#125;)        end    &#125;,    &#123;        &quot;folke/flash.nvim&quot;,        event = &quot;VeryLazy&quot;,        ---@type Flash.Config        opts = &#123;&#125;,        -- stylua: ignore        keys = &#123;            &#123; &quot;s&quot;, mode = &#123; &quot;n&quot;, &quot;o&quot;, &quot;x&quot; &#125;, function() require(&quot;flash&quot;).jump() end, desc = &quot;Flash&quot; &#125;,            &#123; &quot;S&quot;, mode = &#123; &quot;n&quot;, &quot;o&quot;, &quot;x&quot; &#125;, function() require(&quot;flash&quot;).treesitter() end, desc = &quot;Flash Treesitter&quot; &#125;,            -- &#123; &quot;r&quot;, mode = &quot;o&quot;, function() require(&quot;flash&quot;).remote() end, desc = &quot;Remote Flash&quot; &#125;,            &#123; &quot;R&quot;, mode = &#123; &quot;o&quot;, &quot;x&quot; &#125;, function() require(&quot;flash&quot;).treesitter_search() end, desc = &quot;Treesitter Search&quot; &#125;,            &#123; &quot;&lt;c-s&gt;&quot;, mode = &#123; &quot;c&quot; &#125;, function() require(&quot;flash&quot;).toggle() end, desc = &quot;Toggle Flash Search&quot; &#125;,        &#125;,    &#125;&#125;)--                                                     _--                   __   __  ___    ___    ___     __| |   ___--                   \\ \\ / / / __|  / __|  / _ \\   / _` |  / _ \\--                    \\ V /  \\__ \\ | (__  | (_) | | (_| | |  __/--                     \\_/   |___/  \\___|  \\___/   \\__,_|  \\___|----                                             __   _--                      ___    ___    _ __    / _| (_)   __ _--                     / __|  / _ \\  | &#x27;_ \\  | |_  | |  / _` |--                    | (__  | (_) | | | | | |  _| | | | (_| |--                     \\___|  \\___/  |_| |_| |_|   |_|  \\__, |--                                                      |___/--local map = vim.keymap.setlocal expr_options = &#123; expr = true, silent = true &#125;-- 这里很重要,防止光标到折叠为止,折叠自动展开map(&quot;n&quot;,&quot;k&quot;,&quot;gk&quot;,&#123;remap = true&#125;)map(&quot;n&quot;,&quot;j&quot;,&quot;gj&quot;,&#123;remap = true&#125;)map(&#x27;n&#x27;,&#x27;zc&#x27;,&quot;&lt;cmd&gt;call VSCodeCall(&#x27;editor.fold&#x27;)&lt;cr&gt;&quot;)map(&#x27;n&#x27;,&#x27;zo&#x27;,&quot;&lt;cmd&gt;call VSCodeCall(&#x27;editor.unfold&#x27;)&lt;cr&gt;&quot;)map(&#x27;n&#x27;,&#x27;zR&#x27;,&quot;&lt;cmd&gt;call VSCodeCall(&#x27;editor.unfoldAll&#x27;)&lt;cr&gt;&quot;)map(&#x27;n&#x27;,&#x27;zM&#x27;,&quot;&lt;cmd&gt;call VSCodeCall(&#x27;editor.foldAll&#x27;)&lt;cr&gt;&quot;)map(&#x27;n&#x27;,&#x27;&lt;leader&gt;e&#x27;,&quot;&lt;cmd&gt;call VSCodeCall(&#x27;workbench.action.quickOpenNavigateNextInFilePicker&#x27;)&lt;cr&gt;&quot;,&#123;remap=true&#125;)\n\n注意\n123-- 这里很重要,防止光标到折叠为止,折叠自动展开map(&quot;n&quot;,&quot;k&quot;,&quot;gk&quot;,&#123;remap = true&#125;)map(&quot;n&quot;,&quot;j&quot;,&quot;gj&quot;,&#123;remap = true&#125;)\n\n这两句配置很是很重要的,如果不配置,在neovim模式下,光标移动到折叠为止,折叠会自动展开\n","slug":"vscode-neovim-plugin","date":"2023-09-23T19:10:04.000Z","categories_index":"万物皆可vim","tags_index":"vim,vscode","author_index":"finger"},{"id":"9b2c63c47c8da4d4585e94b67802d226","title":"idea下配置vim模式","content":"vim搓一切?有一说一,vim虽然可以配置的很舒服,但是对于java程序员来说,用vim去写java是真的折磨,除非你想进行自我折磨,变成代码仙人.所以最省心的方案就是在idea中下一个vim插件\n安装首先你要有一个 java第一 IDE:intellij idea然后打开插件市场,下一个idea vimrc 安装上\n配置.ideavimrc创建一个~/.ideavimrc\n加入一些配置:\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157&quot;                   ____       _      ____    ___    ____&quot;                  | __ )     / \\    / ___|  |_ _|  / ___|&quot;                  |  _ \\    / _ \\   \\___ \\   | |  | |&quot;                  | |_) |  / ___ \\   ___) |  | |  | |___&quot;                  |____/  /_/   \\_\\ |____/  |___|  \\____|&quot; 上下预留5行set so=5&quot; 不折叠 set nowrap&quot; 去掉哔哔声set belloff=allset noerrorbellsset t_vb=set backspace=indent,eol,start whichwrap+=&lt;,&gt;,[,]&quot; Vim 的默认寄存器和系统剪贴板共享set clipboard+=unnamedplusset keep-english-in-normal&quot; 开启相对行set relativenumberset nuset ignorecaseset smartcase&quot;                   ____    _       _   _    ____   ___   _   _&quot;                  |  _ \\  | |     | | | |  / ___| |_ _| | \\ | |&quot;                  | |_) | | |     | | | | | |  _   | |  |  \\| |&quot;                  |  __/  | |___  | |_| | | |_| |  | |  | |\\  |&quot;                  |_|     |_____|  \\___/   \\____| |___| |_| \\_|&quot;&quot;&quot;开启多光标支持Plug &#x27;machakann/vim-highlightedyank&#x27;Plug &#x27;vim-scripts/argtextobj.vim&#x27;Plug &#x27;justinmk/vim-sneak&#x27;Plug &#x27;easymotion/vim-easymotion&#x27;Plug &#x27;unblevable/quick-scope&#x27;Plug &#x27;preservim/nerdtree&#x27;Plug &#x27;tpope/vim-commentary&#x27;&quot;USAGE &quot; add surround&quot; ys&#123;textobject motion&#125;&#123;indeifier&#125;&quot; eg:&quot;   ysiw&#x27;&quot;&quot; remove surround &quot; ds&#x27;&quot;&quot; change surround &quot; cs[(Plug &quot;tpope/vim-surround&quot;&quot;USAGE &quot; [count][&quot;x]gr&#123;motion&#125;   Replace &#123;motion&#125; text with the contents of register x.&quot;                         Especially when using the unnamed register, this is&quot;                         quicker than &quot;_d&#123;motion&#125;P or &quot;_c&#123;motion&#125;&lt;C-R&gt;&quot;&quot; [count][&quot;x]grr          Replace [count] lines with the contents of register x.&quot;                         To replace from the cursor position to the end of the&quot;                         line use [&quot;x]gr$&quot; &#123;Visual&#125;[&quot;x]gr          Replace the selection with the contents of register x.&quot;Plug &#x27;vim-scripts/ReplaceWithRegister&#x27;&quot; USAGE &quot; cx&quot; On the first use, define the first &#123;motion&#125; to exchange. On the second use, define the second &#123;motion&#125; and perform the exchange.&quot;&quot; cxx&quot; Like cx, but use the current line.&quot;&quot; X&quot; Like cx, but for Visual mode.&quot;&quot; cxc&quot; Clear any &#123;motion&#125; pending for exchange.&quot;Plug &#x27;tommcdo/vim-exchange&#x27;Plug &#x27;terryma/vim-multiple-cursors&#x27;&quot; quick-scop cofniglet g:qs_highlight_on_keys = [&#x27;f&#x27;, &#x27;F&#x27;, &#x27;t&#x27;, &#x27;T&#x27;]let g:qs_accepted_chars = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;] &quot; https://github.com/JetBrains/ideavim/wiki/ideajoin-examplesset ideajoinset sneak&quot;                   _  __  _____  __   __  __  __      _      ____&quot;                  | |/ / | ____| \\ \\ / / |  \\/  |    / \\    |  _ \\&quot;                  | &#x27; /  |  _|    \\ V /  | |\\/| |   / _ \\   | |_) |&quot;                  | . \\  | |___    | |   | |  | |  / ___ \\  |  __/&quot;                  |_|\\_\\ |_____|   |_|   |_|  |_| /_/   \\_\\ |_|&quot; basic key map inoremap &lt;C-e&gt; &lt;END&gt;inoremap &lt;C-a&gt; &lt;HOME&gt;inoremap &lt;C-f&gt; &lt;Right&gt;inoremap &lt;C-b&gt; &lt;Left&gt;inoremap &lt;C-n&gt; &lt;Down&gt;inoremap &lt;C-p&gt; &lt;Up&gt;inoremap &lt;M-f&gt; &lt;S-Right&gt;inoremap &lt;M-b&gt; &lt;S-Left&gt;inoremap &lt;C-k&gt; &lt;ESC&gt;d$iinoremap &lt;C-d&gt; &lt;Del&gt;let mapleader=&quot; &quot;&quot; idea action confignnoremap gd &lt;Action&gt;(GotoDeclaration)nnoremap gi &lt;Action&gt;(GotoImplementation)nnoremap gs &lt;Action&gt;(GotoSuperMethod)nnoremap gt &lt;Action&gt;(GotoTypeDeclaration)map &lt;leader&gt;re  &lt;Action&gt;(RenameElement)map &lt;leader&gt;gf &lt;Action&gt;(GotoFile)map &lt;leader&gt;gt &lt;Action&gt;(GotoSymbol)map &lt;leader&gt;f: &lt;Action&gt;(GotoAction)map &lt;leader&gt;f. &lt;Action&gt;(FindInPath)map &lt;leader&gt;fl &lt;Action&gt;(RecentLocations)map &lt;leader&gt;ff  &lt;Action&gt;(RecentFiles)map &lt;leader&gt;et :NERDTreeToggle&lt;CR&gt;map &lt;leader&gt;ef :NERDTreeFocus&lt;CR&gt;map &lt;leader&gt;es &lt;Action&gt;(FileStructurePopup)nmap &lt;C-W&gt;q &lt;Action&gt;(CloseAllEditors)&quot; plugin config let g:multi_cursor_use_default_mapping=0&quot; Default mappinglet g:multi_cursor_start_word_key      = &#x27;&lt;C-n&gt;&#x27;let g:multi_cursor_select_all_word_key = &#x27;&lt;A-n&gt;&#x27;let g:multi_cursor_start_key           = &#x27;g&lt;C-n&gt;&#x27;let g:multi_cursor_select_all_key      = &#x27;g&lt;A-n&gt;&#x27;let g:multi_cursor_next_key            = &#x27;&lt;C-n&gt;&#x27;let g:multi_cursor_prev_key            = &#x27;&lt;C-p&gt;&#x27;let g:multi_cursor_skip_key            = &#x27;&lt;C-x&gt;&#x27;let g:multi_cursor_quit_key            = &#x27;&lt;Esc&gt;&#x27;\n\n让其生效打开idea,source一下\n1source ~/.ideavimrc\n\nFBI WARNING\n.ideavimrc里面有一些插件是要在idea中也要下载对应的插件才能使用的,具体参考这里\nmap &lt;leader&gt;f: &lt;Action&gt;(GotoAction) 这种形式是在调用idea的原生功能,具体有哪些功能,可以参考这里,可以打开ideavim的插件,查看对应操作的&lt;ActionId&gt;\n\n\n","slug":"intellij-idea-config-vim","date":"2023-09-22T17:04:46.000Z","categories_index":"万物皆可vim","tags_index":"idea,vim","author_index":"finger"},{"id":"21c88c674175238dff17f5ecc1cb05a5","title":"java byte array 转String在转回byte array不相等","content":"背景最近在搞微软的NBFS协议,这个协议实际上也是基于WebService,只不过对xml进行了压缩,按照他自己的编码规则进行压缩网上搜罗一圈后发现有个大佬写好的burp的NBFS插件WCF-Binary-SOAP-Plug-In这个插件会将传入的经过base64编码的xml转换成NBFS协议的base64编码的字符串\n测试那边要使用jmeter对这个NBFS接口性能测试基本思路:\n\n新建http request输入原始的xml\n搞一个PreProcessor,调用大佬写的NBFS.exe获取压缩后的XMLbase64编码的字符串\n\nPreProcessor 代码如下\n1234567891011121314151617181920import org.apache.commons.codec.binary.Base64;// 获取请求体数据def requestBody = sampler.getArguments().getArgument(0).getValue();// 检查请求体是否存在if (requestBody != null) &#123;    log.info(&quot;获取到请求体:&#123;&#125;&quot;,requestBody)    // 进行加密操作，这里使用Base64编码作为示例    def reqBase64Str = Base64.encodeBase64String(requestBody.getBytes());    def process = Runtime.getRuntime().exec(&quot;./NBFS.exe&quot;,&quot;encode&quot;,reqBase64Str)    process.waitFor()    def nbfsEncodeBase64Str = process.inputStream.text    def result = Base64.decodeBase64(nbfsEncodeBase64Str)    // 将加密后的数据设置回请求体    sampler.getArguments().getArgument(0).setValue(new String(result));&#125; else &#123;    log.warn(&quot;请求体不存在&quot;);&#125;\n\n这时候就会发现一个神奇的东西,接口会返回400错误\n问题分析先说明下NBFS编码的原理,为了压缩xml,NBFS会预先定义一些字典,比如:0x90代表Reason这个字符,也就是说,经过NBFS.exe返回的Base64字符串经过Base64.decodeBase64(nbfsEncodeBase64Str)这个方法返回的byte数组中可能出现0x80,0xAA等字节\n众所周知,java默认的字符串编码是UTF-8\n另一个常识是:java字符串是由Char[]表示的,而Char是由unicode表示\nok,有了上面的已知条件,返回400的问题,就是解释为什么下面代码输出是false就行了\n1234byte[] byteArray = new byte[]&#123;0x01, (byte)0x81, (byte)0xAA, 0x44, 0x45&#125;;String str = new String(byteArray);byte [] revertByteArray = str.getBytes();System.out.println(Arrays.equals(byteArray,revertByteArray));\n\n其实断点调试下,会发现其实revertByteArray这个数组其实是:[1, -17, -65, -67, -17, -65, -67, 68, 69]而原数组是:[1, -128, -86, 68, 69]区别就是多出了6个byte,其中0x81,0xAA对应变成[-17,-65,-67],对应10进制的65533,对应的unicde就是:\\uFFFD\n接下来就分析一下为什么0x81为什么会变成[-17,-65,-67]这玩意就行了\ndebug大法对new String(byteArr)这段代码开始debug,就会发现最终会进入一个超长的方法:\nsun.nio.cs.UTF_8.Decoder#decode:\n123456789101112131415161718192021222324252627282930313233343536373839404142434445// da 就是字符串找保存的char[]// sa 就是String构造函数传进来的byte 数组// 就是这个方法将byte [] -&gt; char []// sp 是0,应该是偏移量,      String str = new String(byteArray,1,1,&quot;UTF-8&quot;);这么创建字符串才会有,这个不重要,// len就是byte数组的长度public int decode(byte[] sa, int sp, int len, char[] da) &#123;            final int sl = sp + len;            int dp = 0;            int dlASCII = Math.min(len, da.length);            ByteBuffer bb = null;  // only necessary if malformed            // ASCII only optimized loop            //性能优化,&gt;= 0的意思就是byte没有溢出,也就是:0~128,对应就是0x00 到 0x00 0x80            while (dp &lt; dlASCII &amp;&amp; sa[sp] &gt;= 0)                da[dp++] = (char) sa[sp++];            //下面就是范围判断,判断byte是否在utf8的编码范围内            while (sp &lt; sl) &#123;                int b1 = sa[sp++];                if (b1 &gt;= 0) &#123;                    // 1 byte, 7 bits: 0xxxxxxx                    da[dp++] = (char) b1;                &#125; else if ((b1 &gt;&gt; 5) == -2 &amp;&amp; (b1 &amp; 0x1e) != 0) &#123;                    // 2 bytes, 11 bits: 110xxxxx 10xxxxxx                    .                    .                    .                &#125; else if ((b1 &gt;&gt; 4) == -2) &#123;                    // 3 bytes, 16 bits: 1110xxxx 10xxxxxx 10xxxxxx                    .                    .                    .                &#125; else if ((b1 &gt;&gt; 3) == -2) &#123;                    // 4 bytes, 21 bits: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx                    .                    .                    .                &#125; else &#123;                    if (malformedInputAction() != CodingErrorAction.REPLACE)                        return -1;                    da[dp++] = replacement().charAt(0);                &#125;            &#125;            return dp;        &#125;\n\n\n\n上面代码翻译成人话就是:循环byte数组里面的每一个byte\n\n如果&gt;&#x3D;0,就是ASCII\n如果不是,判断是否符合条件:\n1 byte, 7 bits: 0xxxxxxx\n2 bytes, 11 bits: 110xxxxx 10xxxxxx\n3 bytes, 16 bits: 1110xxxx 10xxxxxx 10xxxxxx\n4 bytes, 21 bits: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n\n如果都不符合,就返回replacement()第0个char(打断点看,这个字符其实就是main类启动时创建的,其实这就是’65533’也就是\\uFFFD)\n\n至此,真相大白\n0x80-&gt;0b100000000x88-&gt;0b10010000\n都不在上面的范围,所以他们最终的char最终都会变成65533(\\uFFFD)\n其实上面的规则就是UTF-8规则,参考维基百科:\n\n\n\n\n\n\n\n\n\n  在ASCII码的范围，用一个字节表示，超出ASCII码的范围就用字节表示，这就形成了我们上面看到的UTF-8的表示方法，这样的好处是当UNICODE文件中只有ASCII码时，存储的文件都为一个字节，所以就是普通的ASCII文件无异，读取的时候也是如此，所以能与以前的ASCII文件兼容。  大于ASCII码的，就会由上面的第一字节的前几位表示该unicode字符的长度，比如110xxxxx前三位的二进制表示告诉我们这是个2BYTE的UNICODE字符；1110xxxx是个三位的UNICODE字符，依此类推；xxx的位置由字符编码数的二进制表示的位填入。越靠右的x具有越少的特殊意义。只用最短的那个足够表达一个字符编码数的多字节串。注意在多字节串中，第一个字节的开头”1”的数目就是整个串中字节的数目。\n太长不看一句话总结:因为类似0x80,0x88等字节不在utf-8编码范围内,所以会返回一个默认字符,\\uFFFD(65533),这个字符占3个字节,所以就造成的两个byte数组不相等\n解决方法解决方法很简单:找一个编码覆盖0x00 到 0xff,并且只用一个字节编码的编码格式就行,没错,就是你-ISO-8859-1!\n所以下面代码输出就是true\n1234byte[] byteArray = new byte[]&#123;0x01, (byte)0x81, (byte)0xAA, 0x44, 0x45&#125;;String str = new String(byteArray,&quot;ISO-8859-1&quot;);byte [] revertByteArray = str.getBytes(&quot;ISO-8859-1&quot;);System.out.println(Arrays.equals(byteArray,revertByteArray));\n\n","slug":"java-byte-convert-string-not-equal","date":"2023-09-21T20:39:21.000Z","categories_index":"java","tags_index":"java,encode","author_index":"finger"},{"id":"a80e863ad04e203843f50e139a5edeb2","title":"macos下,实现vim切换模式自动切换输入法","content":"macos下,实现vim切换模式自动切换输入法作为一个重度vim模式使用用户,切换模式输入法不自动切换一直是一个蛋疼的问题,目前主要解决方案就是使用im-select,在对应使用的应用里面设置im-select的路径但是这种方式有一个问题就是如果应用不支持,就不会自动切换\n另一种方式就是使用rime输入法,但是对于我来说配置成本太高,不划算.\n经过我的研究,发现karabiner可以实现在任意应用中使用vim,按下对应的模式切换键实现自动切换输入法.\n安装karabinerkarabiner是mac下一个按键功能映射的软件,可以自己定义json文件实现许多复杂的功能的映射\nbrew不解释连招\n1brew install karabiner\n\n安装im-select继续brew不解释连招\n1brew install im-select\n\n创建映射文件/Users/fingerfrings/.config/karabiner/assets/complex_modifications路径创建一个vim-esc.json文件\n文件内容如下:\n12345678910111213141516171819202122232425262728&#123;  &quot;title&quot;: &quot;Vim shortcuts&quot;,  &quot;rules&quot;: [     &#123;      &quot;description&quot;: &quot;Map ^+[ to esc&quot;,      &quot;manipulators&quot;: [        &#123;          &quot;type&quot;: &quot;basic&quot;,          &quot;from&quot;: &#123;            &quot;key_code&quot;: &quot;open_bracket&quot;,            &quot;modifiers&quot;: &#123;              &quot;mandatory&quot;: [&quot;control&quot;]            &#125;          &#125;,          &quot;to&quot;: [            &#123;              &quot;key_code&quot;: &quot;escape&quot;            &#125;,&#123;              &quot;shell_command&quot;: &quot;/usr/local/bin/im-select com.apple.keylayout.ABC&quot;            &#125;          ]        &#125;      ]     &#125;,      ]&#125;\n\n上面文件的映射内容就是将Ctrl-[映射为Esc,同时执行/usr/local/bin/im-select com.apple.keylayout.ABC命令\n设置karabiner在complex Modifications选项中启用Map ^+[ to esc\n参考文档https://karabiner-elements.pqrs.org/docs\n","slug":"macos-vim-auto-change-input-method","date":"2023-09-20T10:37:19.000Z","categories_index":"some litttle tricks","tags_index":"vim,macos","author_index":"finger"},{"id":"3a126c86808bf36e1aa89411751a60c9","title":"hexo push后自动部署github pages","content":"hexo 提交后自动部署github pagehexo有几种部署方式,一种是本地编译后,直接push public路径下的静态文件,一种是通过cli方式,向仓库提交source下的的markdown文件,触发action.实现自动部署\n本文主要说明后一种方式.\n创建github workflow在hexo的根目录的.github/workflows/pages.yml路径下创建文件,文件内容:\n123456789101112131415161718192021222324252627282930313233343536373839name: Pageson:  push:    branches:      - main  # default branchjobs:  pages:    runs-on: ubuntu-latest    permissions:      contents: write    steps:      - uses: actions/checkout@v3        with:          token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;          # If your repository depends on submodule, please see: https://github.com/actions/checkout          submodules: recursive      - name: Use Node.js 16.x        uses: actions/setup-node@v2        with:        # 看下自己本地的noe版本          node-version: &#x27;16&#x27;      - name: Cache NPM dependencies        uses: actions/cache@v2        with:          path: node_modules          key: $&#123;&#123; runner.OS &#125;&#125;-npm-cache          restore-keys: |            $&#123;&#123; runner.OS &#125;&#125;-npm-cache      - name: Install Dependencies        run: npm install      - name: Build        run: npm run build      - name: Deploy        uses: peaceiris/actions-gh-pages@v3        with:          github_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;          publish_dir: ./public\n\n\n创建github pages参考 https://docs.github.com/en/pages/getting-started-with-github-pages/creating-a-github-pages-site\n创建完成后,微调一下:\n在settings-&gt;Pages-&gt;Build and deployment-&gt;Branch选项中,把branch改成gh-pages\n初始化本地仓库1234git init .git remote add origin $&#123;你上面创建的仓库地址&#125;git remote add  .git commit  -m &quot;init project&quot;\n\ngitgnore由于使用了github的自动部署功能,所以无需上传静态文件,在hexo根目录添加.gitignore文件\n123public/.deploy*/node_modules\n\n提交最后提交到main分支\n1git push -u origin main\n提交完成后,在github的action选项中可以看到正在构建,构建完成,就可以在https://$&#123;your-username&#125;.github.io路径访问你的在线博客了\n参考https://hexo.io/docs/github-pages\n","slug":"hexo-auto-deploy","date":"2023-09-20T09:31:18.000Z","categories_index":"hexo","tags_index":"hexo","author_index":"finger"}]